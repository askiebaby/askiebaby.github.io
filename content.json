{"pages":[{"title":"","text":"","link":"/README.html"},{"title":"林汶樺 | Askie Lin","text":"我是 Askie Lin，一位前端工程師。 這裡是我放置想法、靈感與筆記的部落格，平常喜歡透過實驗性的事情來驗證學習，Web 技術實在是很有趣且永遠學不完的領域，自從與好想工作室夥伴們一同參與 iT 邦鐵人賽寫完實踐無障礙網頁設計（Web Accessibility）更加深對於親和力網頁的關注。 Learning now 正確姿勢打字 JavaScript Testing Habits 運動：間歇有氧、肌耐力等訓練 彈木吉他 照顧貓咪 有共同興趣都歡迎一起討論，文章有錯誤也請不吝指正唷 ^_^","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"使用手機測試本機網頁狀況的方法","text":"前置 確保電腦與手機裝置是在同一個網域底下 要確認電腦是否有裝 python 方法（2019-07-16 更新） 在 iTerm 進入專案的資料夾根目錄。 找到對外 IP，要找 IPV4 的 。 ifconfig // MacOS ipconfig // Windows 輸入以下指令，預設 port 是 8000。 port 儘量使用 4 位數以上（因爲有一些是預設的 port 號，可能會有重疊到的可能） python -m SimpleHTTPServer [port] 在瀏覽器輸入 IP:port，直接對外測試。","link":"/testing-for-mobile-browsers/"},{"title":"Git diff 指令快速查詢！","text":"名詞解釋 Staging Area (Index) 暫存區域是一個單純的檔案，一般來說放在 Git 目錄，儲存關於下一個提交的資訊。有時稱為索引（Index），但現在將它稱為暫存區域已開始成為標準。 用來比較差異的 diff 指令 比較 Working Directory 和 Staging Area git diff 比較 Working Directory 和 HEAD git diff head 比較 Working Directory 和該 commit 的 tree 物件 git diff commit 比較 Staging Area 和 HEAD git diff --cached git diff --cached head git diff --staged 比較 Staging Area 和該 commit 的 tree 物件 git diff --cached commit 比較兩個 branch 之間的 HEAD git diff branchName..branchName git diff branchName branchName 比較 branch2 和兩個 branch 的共同祖先 git diff branch1...branch2 比較兩個 commit 物件下的 tree 物件 git diff commit commit","link":"/git-diff-cheatsheet/"},{"title":"JavaScript 十個單字","text":"1. array 複數 像火車車廂的概念。 有順序性，可以放各種資料，但建議資料類型相似的一組資料結構/格式。 適合資料處理。 表達複數的概念，多個相同的複類別。 可以放不一樣型別的值，而強型別語言中都會相同型別的值。（2019-7-16 更新） 2. object 單數 單體 描述 Key，紀錄 value。 儲存某個東西各種屬性及方法，可以相關也可以不相關。 以車子舉例，有幾個輪子及什麼功能。 與類別的差異？類別可以抽換參數跟變數，可以複製相同的輪子。 狗(class)跟一隻狗(object)的差別！ pair，為值命名 用有意義的詞找到結果的一個容器 抽出我要的特性來描述，叫做抽象，很具象的。取決於問題。 class 抽象的結果，template 3. json 資料型別？ String 用來做什麼的？ 資料交換的格式。 輕便、傳 API、紀錄資料。 xml的另一個選擇，xml 不常被選擇使用，是因為適合拿來描述更複雜的東西，而傳輸資料通常較簡單。xml 體積大需要用套件解析才能給js使用。 parse，丟 json 吐出 object stringify，丟 object 吐出 json (String) 4. callback 把 function 當參數傳入另一個 function，就叫做 callback 需要某個 function 執行完，執行後才會執行的 function 異步常用 callback 就算沒有回傳值也是 callback 一定要用 CPS 攥寫風格 Ｑ：I/O? HOF?? 5. function 意思？ 一段可重複使用的程式碼，可當參數也可以接受參數 在js中提供什麼重要特性？（非他不可的特性） 建物件、一般用法 提供一個私有的命名環境（Scope） Lexical Environment 表現一個動詞、動作就會使用 function 可以選擇 return 或不 return 6. asyncronous 阻塞（blocking）：會造成等待的事情。要不要等待上一行結束，才執行我這一行。 常見同步阻塞、異步不阻塞 JS單執行緒的特性，會放到事件佇列的 function，避免阻塞到其他程式的執行 點餐範例、小鳥協助打果汁的範例 唯一讓 JS 非單線程的方法 配合執行環境而發生 7. closure 閉包 主要為了什麼而存在？ 在 function被產生當下記住其與會環境，在執行環境消失後仍可使用，因為記憶體位置保留著。 避免污染全域環境。 用程式形容？ function a (x) { return() =&gt; console.log(x++); }; var b = a(1); b(); // 1 b(); // 2 JS用closure做什麼事？ 閉了誰，閉包的殺手級應用，就是要知道怎麼加上，怎麼拿掉。才知道閉包必要所在 =&gt; 避免全域污染。 8. Array.prototype.map() 遍歷 array 當中的每一個值，執行一個方法，回傳一個與原陣列同長的新 Array，不影響原本的陣列。 由 map 中的 callback 可自訂對 array item 做的事情 會 return 一個與相同長度的array immutable method 所有輸出都和輸入有關（一對一映射，映射函數） 9. loop 在特定條件下執行重複的程式碼，重複做一件事直到不符合條件 for // 知次數 while // 不知次數 do ... while // 不知次數，至少一次 10. switch 是什麼？ 由上而下，進行條件（強制===）判斷，符合後執行直到 break 類似於菜單，廚師照點餐內容出餐 重點是滿足條件後，要從哪裡開始執行，下 break; 才停止 幾種寫法？（2019-7-16 更新） // example 1 var fruit = 'Cherry'; switch(fruit) { case 'Apple': doSomething(); break; case 'Banana': doSomething(); break; Default: doSomething(); break; } // example 2 switch(somethingTrue) { case a&gt;b: doSomething(); break; case a==b: doSomething(); break; Default: doSomething(); break; }","link":"/javascript-ten-keywords/"},{"title":"ngrok 的設定，來架一個臨時伺服器！","text":"緣起 為了解決 facebook API 需要 https，所以利用 ngrok 架了一個網頁伺服器（Web Server）。 跟著步驟做，輕鬆就能架起來，並且可以達成以下這些事： Public URLs for sending previews to clients. 讓客戶可以輕鬆預覽你的專案。 Public URLs for testing your chatbot. 測試你的機器人。 Public URLs for SSH access to your Raspberry Pi. 輕鬆設定 SSH 連結樹莓派。 Public URLs for demoing from your own machine. 從自己的裝置 demo。 Public URLs for exposing your local web server. 架一個臨時伺服器。 Public URLs for testing on mobile devices. 測試行動裝置。 Public URLs for building webhook integrations. 步驟 1. 從官網下載 ngrok。 網址 2. 解壓縮 將檔案放在你的專案下，並且點兩下執行。 3. 取得 token 從官網註冊你的信箱，取得 token 4. 開啟你的 terminal（我使用 iTerm），進入專案底下執行： ./ngrok authtoken &lt;YOUR_AUTH_TOKEN&gt; 5. 架起渠道： ./ngrok http 80 6. 讓 localhost 對外 用 Python 的 SimpleHTTPServer 模組建立一個臨時網頁伺服器（Web Server），port 要與 ngrok 要開的 port 相同。 python -m SimpleHTTPServer [port] 7. 大功告成 可以透過網址直接讓localhost 對外進行測試囉！不過要注意的是，如果關閉server，網址也會失效，下次重啟則是新的網址。","link":"/ngrok-localhost-server-settings/"},{"title":"使用 JQuery 透過 FormData 上傳檔案 (headers 帶 boundary)","text":"基礎知識 JQuery AJAX: contentType 不填寫時，預設為 application/x-www-form-urlencoded 。 FormData FormData 介面可為表單資料中的欄位/值建立相對應的的鍵/值對（key/value）集合，之後便可使用 XMLHttpRequest.send() 方法來送出資料。 它在編碼類型設定為 multipart/form-data 時會採用與表單相同的格式送出。 RFC1867 剛開始，http 協議中没有檔案上傳的功能，直到 RFC1867 為 http 協議添加了此功能。 在 RFC1867 中限定： &lt;form&gt; 的 method 必須是 POST。 enctype 屬性新增了 multipart/form-data 的選項。 &lt;input&gt; 的 type 屬性增加了 file 選項。 程式碼 html &lt;form action=&quot;server/api/items&quot; name=&quot;productForm&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&gt; &lt;h3&gt;新增商品&lt;/h3&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot; class=&quot;productFile&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;productName&quot;&gt; &lt;input type=&quot;number&quot; min=&quot;1&quot; class=&quot;productPrice&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;送出&quot;&gt; &lt;/form&gt; JavaScript // 取得表單 let productForm = document.forms.namedItem('productForm') productForm.addEventListener('submit', function(event){ post_items(event, productForm) }) function api_post_items (event, form){ // 取消表單預設提交 event.preventDefault() let name = document.querySelector('.productName').value let stock = document.querySelector('.productAmount').value let unit_price = document.querySelector('.productPrice').value let file = $('.productFile')[0].files[0] // 單個檔案 // 建立一個新的 FormData 物件 let formData = new FormData(form) // 追加新值到 FormData 物件已有的對應鍵上；若該鍵不存在，則為其追加新的鍵 formData.append('name', name) formData.append('cost', cost) formData.append('unit_price', unit_price) formData.append('images', file) let item = { 'url': `${ server }/api/items`, 'type': 'POST', 'headers': { // 'Content-Type': 'multipart/form-data', // 使用 multipart/form-data 在此不需要設定 Content-Type。 'X-Requested-With': 'XMLHttpRequest', 'Authorization': `Bearer ${ userToken }`, }, 'contentType': false, //required 'processData': false, // required 'mimeType': 'multipart/form-data', 'data': formData } $.ajax(item) .done(function (response) { console.log(response) closeLightBox() api_get_items() }) .fail(function (response) { console.log('api_post_user: Fail ' + response.responseText) }) } 注意！ 在 &lt;form&gt; 表單設定 enctype=&quot;multipart/form-data&quot;。 &lt;form&gt; 中，需要有 &lt;input type=&quot;file&quot;&gt;。 JavaScript 中 設定 contentType = false。 在傳送 multipart/formdata 時，希望不影響原表單設定，而直接將預設值改為 multipart/form-data。 JavaScript 中 設定 processData = false。 不去處理資料。 JavaScript 中 設定 cache = false，檔案不需緩存。 表單送出後，去檢查 Request Headers 看到我們有帶 boundary 成功傳輸。 Reference FormData - MDN Content-Type - MDN 通过jQuery Ajax使用FormData对象上传文件 浅谈contentType = false 从FormData到图片上传 Submitting multipart/form-data using jQuery and Ajax missing boundary in Content-Type for multipart posts","link":"/using-formdata-and-setting-multipart-to-upload-file-by-ajax/"},{"title":"自訂一個指令同時更新及備份 hexo 部落格（macOS）","text":"Preparation 建立備份的repository hexo 在 _comfig.yml 檔案可以設定部落格 hexo d 部署時，要部署到哪個repository，但是因為部署只會部署 hexo g (generate生成靜態網頁) 的 public 資料夾，我們也希望能備份樣式，所以要開好一個新的repository（我設為private），進入.git/config 修改備份的路徑。 修改 .git/config 檔案 [remote &quot;origin&quot;] url = 準備用來備份樣式跟設定的repository.git fetch = +refs/heads/*:refs/remotes/origin/* 流程 1. 進入 /bin 資料夾： cd /usr/local/bin 2. 檢視目前電腦有哪些指令： ls 3. 自訂你的個人指令，進入 insert 模式編輯內容： vim your-command PS. 若不存在這個檔案（你定義的名稱），vim 會在你儲存內容後自動建立這個檔案 4. 建立批次執行的指令們： #!/bin/bash cd 你的部落格絕對路徑 git add . git commit --amend --no-edit git push -f cd 你的部落格絕對路徑 hexo cl # 刪除已經生成的 public 資料夾 hexo g -d # 根據新內容生成 public 資料夾，並部署上線 :wq 或是 :x 存檔離開，這時候再來 ls 看看指令們當中有出現你自訂的指令了。 可能會遇到的問題 權限不足 檢視指令的權限： ll -a your-command 如果發現權限只可讀，使用以下語法，加上執行的權限： chmod u+x your-command 執行你的指令 your-command 試試吧！ ps. 要確認你的每一行指令，你都知道在做什麼事情，否則會無預期的發生嚴重錯誤喔！","link":"/macos-command-backup-update-hexo-blog/"},{"title":"React 環境設置 (CDN/CRA)","text":"安裝與設定環境 React 從一開始就被設計為逐步採用，可以根據需求來選擇使用 React 的範圍。 CDN 建立一個靜態的 index.html 檔案。 在 head 中載入三個 CDN，分別是 React、React DOM、Babel。 index.html 中寫一個 div，id 是root。 最後在&lt;body&gt; end tag 之前新增script區塊放置程式碼。 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;React_CDN&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.26.0/babel.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // React code will go here &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 目前已經載入寫作時穩定的版本： React - React 頂層的 API React DOM - adds DOM-specific methods The react-dom package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module. Babel - a JavaScript compiler that lets us use ES6+ in old browsers 整個 app 的進入點會是這個 div#root，已經是使用慣例。 現在，使用 ES6 的 class 來寫第一個 React 的程式，新增一個叫做 app 的 component。 class App extends React.Component { //... } 加入 render() 方法，這是 class component 唯一必須存在的 method，用來渲染 DOM 節點。 class App extends React.Component { render() { return ( //... ); } } 在 return 中，簡單放個 HTML 元素。要注意這邊放的類型並不是字串，所以不使用單引號或雙引號把內容包起來。這叫做 JSX，之後會談到更多。 class App extends React.Component { render() { return &lt;h1&gt;Hello, I'm here&lt;/h1&gt; } } 最後，使用 React 提供的 DOM 渲染方法 render() 把 App 這個 class 創建到我們的 div#root 當中。 ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) index.html 最後長這樣 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;React_CDN&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6.26.0/babel.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/babel&quot;&gt; class App extends React.Component { render() { return &lt;h1&gt;Hello, I'm here&lt;/h1&gt; } } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以在瀏覽器看到內容就代表成功了： Local Environment (CRA/Create React App) CDN 引入 libraries 的方法並不是很有效率，也不容易維護，所幸 facebook 提供了create-react-app，它幫你在設定好在開發React App 前的所需的環境。 live server Webpack 自動編譯 React, JSX, and ES6, auto-prefix CSS 檔案 ESLint測試並提醒程式碼錯誤的地方 設定 create-react-app （app 名稱） 打開 terminal，跟著以下步驟安裝。回到你想安裝專案的上一層資料夾，確定一下 Node.js 版本是否在 5.2 或以上。 一、安裝 npx create-react-app create-react-app 二、進入專案資料夾，開始專案 cd create-react-app npm start 專案檔案包含： 觀察專案的結構，可以看到 /public、/src 兩個資料夾，和node_modules、.gitignore、README.md、package.json 這幾個檔案。 在 /public 中，index.html 是我們重要的檔案，跟先前使用 CDN 建立的 index.html 非常相似，都有著 div#root，只是這次沒有載入任何 libraries 和程式碼。 /src 會放置我們所建立的 React 程式碼。 /src/App.js 看環境如何自動編譯，找到以下這行改看動試試更新程式碼及樣板。 To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; 一旦更動程式碼發現 localhost:3000 自動更新樣板，這就是live server。 把 /src 資料夾中的檔案刪除，只留 index.css 和 index.js，不會爆掉。 三、在 index.js 中 import React、ReactDOM、CSS 檔案： import React from 'react' import ReactDOM from 'react-dom' import './index.css' 我們再建立 App component 一次。使用 CDN 方法時，我們有個&lt;h1&gt;元素，但現在我們試著在&lt;div&gt;上加上className取代class來引入樣式規則。這意味著我們正在 JavaScript 中攥寫我們的樣板，而非真實 HTML 檔案。 class App extends Component { render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Hello, I'm here&lt;/h1&gt; &lt;/div&gt; ) } } 四、以下是完整的 index.js，這次我們要把 Component 當作 React 的參數載入，這樣也就不需再 extend React.Component： import React, { Component } from 'react' import ReactDOM from 'react-dom' import './index.css' class App extends Component { render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Hello, I'm here&lt;/h1&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 五、打開瀏覽器 localhost:3000 看看，已經成功開始我們的 React 專案： Reference 參考連結","link":"/react-setting-cdn-and-creatreactapp/"},{"title":"談一下 CSS Specificity","text":"CSS 剛開始學習容易上手 往後卻難以維護 CSS 較鬆散， 非常仰賴攥寫的順序 但這些都比不上不懂 Specificity 的恐怖！XDDD Specificity 看不懂？ Specificity 譯為優先級、特定度、權重 註：Ｏ’reily 翻譯為特定度；MDN 翻譯為優先級；有些翻譯為權重。本文一律以「權重」表示 Specificity。 Specificity 幹嘛的？ 決定你的元素優先吃哪一個樣式的其中一個因素！ Chris 這篇文章解釋得很清楚：Cascade 動作是由 Specificity 和 Ruleset order 作用，決定要套用的 CSS。 換句話說 先比權重，再比順序！ 當兩個 CSS 宣告同時作用在一個元素時： 權重高 優先生效！ 相同權重時 後寫的 CSS 會覆蓋先寫的 CSS 透過範例了解一下剛剛在說什麼 我們有一個區塊元素 div 包覆著一個 button 。 這個 button 的 class 有 button（基本按鈕的樣式）、button__disabled（無法點擊的狀態樣式）。 HTML &lt;div&gt; &lt;button class=&quot;button__disabled button&quot;&gt;Click me&lt;/button&gt; &lt;/div&gt; CSS .button { padding: 10px 20px; font-size: 32px; border-radius: 3px; border: none; /* notice below 被 button__disabled 的樣式覆蓋了 */ background: #eee; color: #333; cursor: pointer; } .button__disabled { background: #ccc; color: #999; cursor: not-allowed; } example - try it 透過範例可以了解兩件事： 決定要套用樣式的基礎並不在於我們在 HTML Element 上引用 Class 的順序，而是，該 class 在我們攥寫 CSS 樣式表當中的順序。 若在同樣都只有一個 class 選擇器的狀況下（.button、.button__disabled） 後面寫的樣式宣告（.button__disabled） 在 CSS 樣式表中，較前面的內容有指定同一個 HTML Element 的選取器（.button） 並且攥寫了重複的內容時（background、color、cursor） 後面寫的樣式宣告（.button__disabled）會優先被套用，覆蓋掉原本的樣式（.button） 權重計算的基本規則 如上圖，檢查對應的出現的次數、由左向右比較，看 W3C 的定義，其實是從 id=&gt; class =&gt; element，檢查完再去看是否有設定 important 行內樣式。但我把它們集合起來畫成一張對應的表，比較方便理解、查閱跟記憶。 我的 CSS Specificity 的 CheatSheet： specificity 條件 1-0-0-0-0 !important 0-1-0-0-0 HTML Element 中的行內樣式， style=&quot;&quot; 0-0-1-0-0 #id 0-0-0-1-0 .class, :pseudo class, attribute 0-0-0-0-1 element (h1), ::pseudo element 0-0-0-0-0 *, +, &gt;, ~, 空格, :not() 例外 :not :not 雖是偽類，可是其無任何權重，但 :not(.class) 依據參數還是會增加權重 有趣的小工具：CSS權重計算機 實例 一個新手容易踩的雷：使用 id 選取器，等專案越做越大時，開始有製作新的 table 需求時… #content table { } /** * 不，我寫的東西無法生效 :( */ .my-new-table { } 命名沒表現任何語意，看不來是何種 table 使用 id 選取器則侷限了這個 table，只能套用在這個名為 content 的 id 中 通常會有兩種做法 重構，移除 id 為了生效，算了不管它了！我要以較高的權重覆蓋它！ 因為若專案較大時，有時無法確定移除 id 對整個專案的影響 使出我的覆蓋技能 #content table { } #content .my-new-table { /* 耶，可以看到我的樣式了！ */ } 結束這回合…了嗎？ 開始進入惡性循環，權重只要一開始疊的高，以後只能越設越高！ !important 該死？ “Rules are the children of principles.” - Jamie Mason When to use !important properly? 有些開發者都覺得 !important 是萬惡的，若 !important 真的如此該死，當初又何必設計它的存在呢？ 其實只要： 了解使用目的！ 確保你的樣式在 global 都要能 work 而不是為了覆蓋（fix）你改不掉的樣式 Keep It Low at All Times 永遠保持最低的權重，這就是原則！ How to keep it low? 絕對不要使用 ID ID 辦得到的事，Class 全部都可以 ID 不能重複使用就算了，還會增加權重 若真無他法一定要使用的話： hack: [id=&quot;your-id&quot;] (attribute 0-0-1-0) （等同於 class 的權重及選取，但可讀性就較低了，不建議不建議不建議！） 選取器不要巢過了頭 建議不要超過三層 不要限定你的選擇器 .nav {} 可以做到的事，不要用 ul.nav {} 盡可能地使用 class 並且保持低權重，讓大家都有相同的權重，公平！ YA！CSS 又 變瘦 變輕了！（是權重不是檔案大小，囧） 理解完，考自己一下，你應該會笑：） 有趣的圖 Reference Spec Calculating a selector’s specificity - W3C Book CSS 重構 - Steve Lindstrom 著、陳健文 譯（好想工作室有這本書） Internet Day20：小事之 CSS 權重 (css specificity) - iT邦幫忙 cssspecificity.com CSS guildlines [Hacks for dealing with specificity - CSS Wizardry](","link":"/css-specificity/"},{"title":"用 JavaScript 一步步打造程式基礎(Huli JS101課程筆記)","text":"Node.js 環境建置 node.js 不是程式語言，而是一個執行環境，能讓 JavaScript 運行於瀏覽器外。 安裝：官網。LTS 是較穩定的版本，Current 是有其他新的功能。 透過 iTerm 建立 js 檔案，並用 node 執行寫好的程式。 1. 建立 JavaScript：vim index.js // index.js console.log(123) 2. 用 node 執行寫好的程式碼 $ node index.js =&gt; 123 直接用 node 執行 JavaScript 1. 執行 $ node =&gt; 等同於進入瀏覽器的 console tab 2. 離開 快速鍵 control + c (輸入兩次) 或是輸入指令： $ .exit 邏輯運算 邏輯運算子 ||（或）、&amp;&amp;（和）、!（not） || 短路性質： 3 || 10 // =&gt; 3 // 程式遇到 3 時，因為是 truthy value，所以直接回傳 3，後面就直接不執行了。 true || 10 // =&gt; true // 程式遇到 true 時，true 符合條件造成短路，後面就直接不執行了。 false || 10 // =&gt; 10 // 程式遇到 false 不符合條件，往後繼續執行，遇到 10 達成條件！回傳 10。 &amp;&amp; 短路性質： 3 &amp;&amp; 10 // =&gt; 10 // 第一個值符合條件，檢查第二個值是否符合條件，回傳第二個值 10。 false &amp;&amp; 10 // =&gt; false // 因為第一個值已經是 false，後面短路不執行，回傳 false。 0 &amp;&amp; 10 // =&gt; 0 // 因為第一個值是 falsy value，後面短路不執行，回傳第一個值 0。 位元運算 位移運算子 &lt;&lt;、&gt;&gt; 了解電腦都是使用二進位做運算 100 =&gt; 2 的三次方 =&gt; 8 1000 =&gt; 2 的四次方 =&gt; 16 往左移 1 位，是乘以 2 倍 往左移 2 位，是乘以 2的2次方（4） 往右移 1 位，是除以 2 倍 往右移 2 位，是除以 2的2次方（4） 10 &lt;&lt; 1 // 20 =&gt; 往左移一位，乘以2的1次方，= 10 * 2 10 &lt;&lt; 3 // 80 =&gt; 往左移三位，乘以2的3次方，= 10 * 8 1024 &gt;&gt; 1 // 512 =&gt; 往右移一位，除以2的1次方，= 1024 / 2 9 &gt;&gt; 1 // 4 =&gt; 往右移一位，除以2的1次方，= 9 / 2，無條件捨去。 10 &gt;&gt; 1 會比 10*2 執行效能還要好。 位元運算子 &amp;、|、xor、not 都會換算成二進位來運算 &amp; and 位元運算子： 10 &amp; 15 // 10 =&gt; 1010 and 1111 = 1010(2) = 10(10) | or 位元運算子： 10 &amp; 15 // 15 =&gt; 1010 or 1111 = 1111(2) = 15(10) xor 位元運算子：當一個 falsy value 和 truthy value 共存時回傳 true，其他都是回傳 false。 10 ^ 15 // 5 =&gt; 1010 xor 1111 = 101(2) = 5(10) not：1變0，0變1 ~15 // -16 =&gt; 1111 = 0000 （因電腦位元關係，原本的1111前有眾多的0，經過not運算會全轉為眾多的1） tips: 判斷數值是奇數或偶數 10 &amp; 1 // 0 =&gt; 判斷最後一個字是零的話，代表是偶數。 11 &amp; 1 // 1 =&gt; 判斷最後一個字是一的話，代表是奇數。 變數 類型 Primitive type and Object type Primitive: string, boolean, number, null, undefined, symbol(ES6) Object: object (array, function, object) undefined: 已宣告，尚未值 not defined: 連宣告都沒啊！ 變數的運算注意的事情 變數是什麼類型！ 浮點數的誤差 複習一下等號的意義 一個等號 =，賦值。 兩個等號 ==，判斷值。 三個等號 ===，判斷類型與值。 let a = 10 == 10 console.log(a) // true，通常先執行右邊的程式 10 == 10，再把判斷結果賦值給 a。 物件與陣列的判斷 console.log([] === []) // false console.log([1] === [1]) // false console.log({} === {}) // false console.log({a: 1} === {a: 2}) //false // 物件的判斷是根據記憶體位置。 // 可以想像我有一台蘋果電腦，你也有一台蘋果電腦，但你的電腦不是我的電腦的概念。 我們只能往不同地方走去：判斷式 if… else… if… else if… else… switch let number = 11 if (!(number % 5)) { // 了解：如果餘數是 0，代表可以被 5 整除 // 但 0 == false，利用 not 特性將結果變成 true 以進入判定 block // （可讀性差） console.log('5的倍數') } else { console.log('不是5的倍數') } ternary 三元運算子 (a &gt; b) ? 'big' : 'small' 迴圈/函式 實現輸入的數值會回傳一個區間陣列 function generateArray (min, max) { var result = [] for(var i = min; i &lt;= max; i++) { result.push(i) } return result } console.log(generateArray(5, 10)) // [5, 6, 7, 8, 9, 10] tip: 實作的時候，如果細節尚不清楚，可以試著先把function列出來，整理出邏輯（流程） 把 function 當成引數傳入 function transform(arr, transformFunction) { var result = [] for (var i = 0; i &lt; arr.length; i++) { result.push(transformFunction(arr[i])) // 執行傳入的 function } return result } function double (num) { return num * 2 } transform([2, 4, 6], double) // 把 function 當成引數傳入 參數（Parameter）與引數（Argument） 參數：定義在 function 中 () 的變數。 引數：呼叫某函式時的 () 的變數。 funtcion myFunc(a, b) { // a, b =&gt; 參數 console.log(arguments.length) // 引數的數量 console.log(arguments[0]) // 第一個引數 return arguments // {a: 1, b: 2} =&gt; 回傳引數類陣列物件 } myFunc(1, 2) // 1, 2 =&gt; 引數 arguments 跟你想的不一樣 arguments 物件是一個對應傳入函式之引數的類陣列（Array-like）物件。（參考：MDN） function 使用注意事項 pass by value pass by sharing https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/ return 不 return，有差嗎？ 差別只在於需不需要結果的。需要結果就回傳。 Number 類型的內建函式 常用的函式 字串轉數字 - 整數 // 沒填進位制的話預設是 10 進位，可接受 2~36 function roughScale(x, base) { var parsed = Number.parseInt(x, base); if (Number.isNaN(parsed)) { return 0; } return parsed * 100; } console.log(roughScale(' 0xF', 16)); // expected output: 1500 console.log(roughScale('321', 2)); // expected output: 0 parseInt('50個') // 50 parseInt('50個', 10) // 50 parseInt('50.2個', 10) // 50 字串轉數字 - 浮點數 parseFloat('20.5') // 20.5 數字轉字串 let num = 1 num.toString() 四捨五入 function calculator (x) { return Math.round(x) } calculator(20.5456789) // 21小數點第一位四捨五入後回傳整數 無條件進位 function calculator (x) { return Math.ceil(x) } calculator(20.3456789) // 20，小數點第一位無條件進位後回傳整數 無條件捨去 function calculator (x) { return Math.floor(x) } calculator(20.3456789) // 20，小數點第一位無條件捨去後回傳整數 小數點後取幾位數（並四捨五入） function calculator (x) { return x.toFixed(2) // 如果都不傳，則直接回傳整數（四捨五入） // 接受 0~20 } calculator(20.5456789) // 20.55 calculator(20.5416789) // 20.54 開根號 function calculator (x) { return Math.sqrt(x) } calculator(9) // 3 平方 function calculator (x, y) { return Math.pow(x, y) } calculator(2, 10) // 1024 最大值 let biggestNum = Number.MAX_VALUE console.log(biggestNum) // 1.7976931348623157e+308 最小值 let smallestNum = Number.MIN_VALUE console.log(smallestNum) // 5e-324 隨機亂數 // 產生 0~0.99999 隨機小數 Math.random() // 產生 1~10 隨機數字 Math.floor(Math.random()*10 +1) 檢查是否是數字 Number.isNaN(NaN); // true Number.isNaN(Number.NaN); // true Number.isNaN(0 / 0); // true // e.g. these would have been true with global isNaN() Number.isNaN('NaN'); // false Number.isNaN(undefined); // false Number.isNaN({}); // false Number.isNaN('blabla'); // false // These all return false Number.isNaN(true); Number.isNaN(null); Number.isNaN(37); Number.isNaN('37'); Number.isNaN('37.37'); Number.isNaN(''); Number.isNaN(' '); String 類型的內建函式 str.length：回傳字串的長度。 toString()：將物件轉字串。 str.replace()：。 ' hello '.trim()：回傳去除 ' hello ' 前後的空格，輸出'hello'這個字串。 str.indexOf('b')：在 str 找不找得到 b ，沒有則回傳 -1，有則回傳第一個 b 的起始位置，沒有則回傳 -1。 str.lastIndexOf('b')：在 str 找不找得到 b ，沒有則回傳 -1，有則回傳最後一個 b 的起始位置。 str.charCodeAt(5)：回傳 str 找第六個字的 keycode。 str.charAt(5)：回傳 str 找第六個字是哪一個字。 str.split(' ')：將 str 這個字串以 空格切開後回傳一個陣列。 str.slice(index1, b)：切字串，但是以範圍來切後回傳，索引也可以從字串最後算起。 var str = 'The quick brown fox jumps over the lazy dog.'; console.log(str.slice(1)); // expected output: &quot;the lazy dog.&quot; console.log(str.slice(4, 19)); // expected output: &quot;quick brown fox&quot; console.log(str.slice(-4)); // expected output: &quot;dog.&quot; console.log(str.slice(-9, -5)); // expected output: &quot;lazy&quot; Array 類型的內建函式 練習 codepen collection 我們只能往不同地方走去：判斷式 練習一：判斷是否及格（連結） 練習二：BMI 計算 （連結） 綜合題目練習 Lv1 練習一：印出一到九（連結） 練習二：寫一個能夠印出 1~n 的函式（連結） 練習三：寫一個能夠印出 n 個 * 的函式（連結） 練習四：寫一個能回傳 n 個 * 的函式（同上連結） 練習五：判斷大小寫（連結） 練習六：回傳第一個大寫字母以及它的 index （連結） 練習七：回傳陣列裡面所有小於 n 的數的數量（連結） 練習八：回傳陣列裡面所有小於 n 的數的總和（連結） 練習九：回傳陣列裡面所有小於 n 的數（連結） 練習十：回傳陣列總和（連結） 綜合題目練習 Lv2 練習一：好多星星（連結） 練習二：好多星星 回傳版（連結） 練習三：好多星星 加強版（連結） 練習四：乘法表（連結） 練習五：九九乘法表（同上連結） 練習六：費式數列（連結） 練習七：字串反轉（連結） 練習八：大小寫互換 練習九：找出最小值 練習十：找出第 n 小的值 綜合題目練習 Lv3 練習一：排序 練習二：壓平陣列 練習三：印出聖誕樹（連結） 練習四：判斷圈圈叉叉勝負（連結） 練習五：判斷質數（連結）","link":"/javascript-js101-note/"},{"title":"開發者一定要知道的 GIT tricks","text":"修改了某些檔案，一次只 commit 其中某幾個檔案 假設我們在開發的過程當中，做了某些檔案的修改。 git status # 看到以下的狀態 On branch develop Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be commited) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: document.json modified: package-lock.json modified: package.json modified: src/app/app.component.html modified: src/app/app.component.ts modified: src/app/app.module.ts modified: src/index.html modified: src/styles.css no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 可是我只希望部分檔案加入 staging area，比如寫 component 時很好用，現在只希望加入 src/app/app.component 開頭的兩個檔案： src/app/app.component.html、src/app/app.component.ts。 # 原本要這樣加入 git add src/app/app.component.html src/app/app.component.ts # 現在只要這樣寫 git add src/app/app.component-* 想加入相同檔案類型的語法就是反過來，比如加入 .html 檔案： git add *.html 下 git log 時，提高可讀性，顯示時間、下 commit 的人 在使用 GIT 的時候，常常需要檢視我們的 commit 紀錄，而查看紀錄的語法是 git log。 一般來說，我們在 terminal下 git log 會看到以下訊息： commit 9a7f06bd416decd8ec8463248d159cde67c48c82 Author: Askie &lt;youremail@gmail.com&gt; Date: Fri Oct 12 13:05:45 內建呈現的格式提供的資訊並不符合每天查閱的需求，所以接下來會教你會加入一個 alias ，指向新的設定。 # 在專案底下查看 git 設定檔 vim ~/.gitconfig # .gitconfig 檔案 [alias] lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --branches git lg 可以看到有顯示以下資訊（請忽略新手還亂亂的 commit 的訊息，以及把顏色改掉了看不出來這件事&gt;//&lt;）： SHA1 HEAD 指向哪個 commit 分支名稱 Commit message 合併分支的流程以圖形介面呈現 多久以前 commit 誰做了這個 commit 更多設定 alias 的內容可以參考為你自己學 Git-其它方便的設定。 本文章內容是參考 egghead.io 的 Juri Strumpflohner 所開的 Productive Git for Developers 課程內容包含下面的情境，想學習的可以去訂閱唷！ 修改了某些檔案，一次只 commit 其中某幾個檔案 下 git log 時，提高可讀性，顯示時間、commit 的人 不小心把 commit 下在 Master，如何移動某些 commits 到另一個新分支？ 取 master 最新的 commit 內容，搬到現在正在開發中的 feature branch 將本地端有 rebase 過的分支 push 到遠端（使用 --force-with-lease） 在提交要給夥伴 review、merge 前，怎樣整理好我們的 git branch 利用 Git Autosquash 自動清理我們的 feature branch（有時候開發途中會發現其他小問題，會產生一些 fix 這種可讀性低的 commits） 整合數個 commits 成一個 commit，並且 merge 到 master message 打錯了！只修改最後一次 commit 的 message 少 commit 一個要的檔案！補到最後一次 commit 當中 取消最後一次 commit 並且將它切成兩個 從 branch 當中永遠移除某個 commit（使用 git reset） 將不小心 push 到遠端 Repository 的 commit 取消 暫存一些正在做的事情，因為我現在需要跳到其他分支","link":"/git-commit-and-git-log-alias-protips/"},{"title":"透過複製陣列理解 JS 的淺拷貝與深拷貝 - JavaScript","text":"本篇文章翻譯自 How to clone an array in JavaScript - by Yazeed Bzadough on freeCodeCamp @medium，搭配 JS 的拷貝 by Kai @github 提及的概念，整理成筆記。 TL; TR 8. JSON.parse and JSON.stringify 是深拷貝。其他都是淺拷貝。 「call by reference」與「call by value」？ 基本型別 (Primitive Type) - number, string, boolean, null, undefined - 傳值 物件 (Objects) - array, function, object - 傳址 array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 「淺拷貝」與「深拷貝」的定義與差異？ 淺拷貝在複製 object 時，會參考到同一個物件，並沒有將此物件拷貝到並建立出新的關聯。 深拷貝在複製 object 時，會獨立出來不共用同一個記憶體位置，改動 newObject 時不會動到 oldObject。 這只是試看看能否用一個步驟就能深拷貝陣列的方式而寫的文章，網路上能找到其他更有趣的實作唷！ 更多深拷貝與淺拷貝的比較也可以參考 Larry Lu、ZHI-WEI jquery - $.extend() loadash - _.cloneDeep() 在 JavaScript 當中，很多方式能複製陣列。 1. Spread Operator・Shallow Copy 展開運算子・淺拷貝 自從 ES6 普及後，展開運算子（Spread Operator）已經成為最熱門的方法，它有著簡潔的語法（Syntax），所以若你使用 React、Redux 這樣的函式庫時會發現它神好用。 const numbers = [1, 2, 3]; const numbersCopy = [1, 5, 6, ...numbers]; // (6) [1, 5, 6, 1, 2, 3] 注意事項：對多維陣列來說，這不是安全的複製。因為 array/object 是 copied by reference 而不是 by value。 [ O ] 基於剛剛的程式碼，單維陣列可以這樣寫： numbersCopy.push(4); console.log(numbers, numbersCopy); // [1, 2, 3] and [1, 5, 6, 1, 2, 3, 4] // numbers 是一個獨立陣列，沒有副作用 [ X ] 假設是多維陣列的情況： const nestedNumbers = [[1], [2]]; const numbersCopy = [...nestedNumbers]; numbersCopy[0].push(300); console.log(nestedNumbers, numbersCopy); // [[1, 300], [2]] // [[1, 300], [2]] // 兩者會同時改變，因為是它們是根據同一個記憶體位址 2. Good Old for() loop・Shallow Copy 好用的老方法 for() loop・淺拷貝 我猜 for() loop 最不受歡迎，因為現在有其他很多新潮的函式可以選擇。 撇除操縱陣列要注意的原則， for() loop 能夠達成目的。 Pure / impure declarative / imperative const numbers = [1, 2, 3]; const numbersCopy = []; for (let i = 0; i &lt; numbers.length; i++) { numbersCopy[i] = numbers[i]; } 注意事項：對多維陣列來說，這不是安全的複製。你使用 = 運算子，會指向該 array/object 的記憶體位置 （ copied by reference 而不是 by value）。 [ O ] 基於剛剛的程式碼，單維陣列可以這樣寫： numbersCopy.push(4); console.log(numbers, numbersCopy); // [1, 2, 3] and [1, 2, 3, 4] // numbers 沒副作用 [ X ] 假設是多維陣列的情況： const nestedNumbers = [[1], [2]]; const numbersCopy = []; for (let i = 0; i &lt; nestedNumbers.length; i++) { numbersCopy[i] = nestedNumbers[i]; } numbersCopy[0].push(300); console.log(nestedNumbers, numbersCopy); // [[1, 300], [2]] // [[1, 300], [2]] // 兩者會同時改變，因為是它們是根據同一個記憶體位址 3. Good Old while() Loop (Shallow copy) 好用的老方法 while() loop・淺拷貝 和 for() 相同，impure、imperative，一樣達成目的。 const numbers = [1, 2, 3]; const numbersCopy = []; let i = -1; // 從 -1 開始，複製的值才會指向正確的 index while (++i &lt; numbers.length) { // 變數 i 先 +1 後才比對是否符合條件 numbersCopy[i] = numbers[i]; } 注意事項：使用 = 運算子，會指向該 array/object 的記憶體位置 （ copied by reference 而不是 by value）。 [ O ] 基於剛剛的程式碼，單維陣列可以這樣寫： numbersCopy.push(4); console.log(numbers, numbersCopy); // [1, 2, 3] and [1, 2, 3, 4] // numbers 沒副作用 [ X ] 假設是多維陣列的情況： const nestedNumbers = [[1], [2]]; const numbersCopy = []; let i = -1; while (++i &lt; nestedNumbers.length) { numbersCopy[i] = nestedNumbers[i]; } numbersCopy[0].push(300); console.log(nestedNumbers, numbersCopy); // [[1, 300], [2]] // [[1, 300], [2]] // 兩者會同時改變，因為是它們是根據同一個記憶體位址 4. Array.map (Shallow copy) 內建的陣列操縱方法 Array.map 映射．淺拷貝 回到現代化的方式，可以使用 map 方法。根據數學理論，其實 Array.map 的概念是，保有原結構下，將一個集合轉成另一個集合（map is the concept of transforming a set into another type of set, while preserving structure.）。 換句話說就是：Array.map 每次都會回傳一個和原陣列長度相同的新陣列。 假設現在要寫一個 numbers 陣列，數字全部乘以 2 的寫法： const numbers = [1, 2, 3]; const double = x =&gt; x * 2; numbers.map(double); 那複製陣列呢？ 沒錯，這篇文章的確是要講如何複製陣列。在 Array.map 方法，要複製陣列只要「回傳」你的元素即可： const numbers = [1, 2, 3]; const numbersCopy = numbers.map(x =&gt; x); 若用數學理論的層面來解讀，(x) =&gt; x 稱為 identity。無論是否有帶參數都直接回傳元素。 map(identity) 本身就是複製一個清單。 const numbers = [1, 2, 3]; const identity = x =&gt; x; const numbersCopy = numbers.map(identity); console.log(numbersCopy); // [1, 2, 3] ，numbers 沒副作用 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 5. Array.filter (Shallow copy) 內建的陣列操縱方法 Array.filter ．淺拷貝 Array.filter 會回傳一個陣列，如同 map，但它不保證回傳與原陣列相同的長度。 濾出偶數：（原陣列長度是 3，而輸出的新陣列長度是 1） [1, 2, 3].filter(x =&gt; x % 2 === 0); // [2] 所以假設你的 filter 過濾的條件只要是 true 都回傳，那就等同於複製了。 const numbers = [1, 2, 3]; const numbersCopy = numbers.filter(() =&gt; true); 陣列當中的每一個元素都達成條件，所以全部都會被回傳到一個新陣列。 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 6. Array.reduce (Shallow copy) 內建的陣列操縱方法 Array.reduce ．淺拷貝 使用 reduce 來複製陣列不是很優，雖然一樣可以解決問題，但 reduce 可以做到比複製陣列更有力量的事。 const numbers = [1, 2, 3]; const numbersCopy = numbers.reduce((newArray, element) =&gt; { newArray.push(element); return newArray; }, []); Array.reduce 在迭代陣列前可以預設一個初始值。 範例中的初始值是空陣列，我們會在迭代原陣列時把單次跑到的「元素」新增至新陣列，而新陣列會被「回傳」，成為下一次迭代的初始值。 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 7. Array.slice (Shallow copy) 內建的陣列操縱方法 Array.slice ．淺拷貝 Array.slice 方法會根據提供的「開始、結束 的 index」回傳陣列的淺拷貝。 如果你只想複製陣列的前三個元素： [1, 2, 3, 4, 5].slice(0, 3); // [1, 2, 3] // 從 index 0 開始, index 3 結束 如果你想複製全部陣列，直接不給參數即可： const numbers = [1, 2, 3, 4, 5]; const numbersCopy = numbers.slice(); // [1, 2, 3, 4, 5] 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 8. JSON.parse and JSON.stringify (Deep copy) ．深拷貝 JSON.stringify：將物件轉字串。 JSON.parse：將字串轉物件。 結合兩者可以達成深拷貝，複製多維陣列，可是會有效能上的問題。 const nestedNumbers = [[1], [2]]; const numbersCopy = JSON.parse(JSON.stringify(nestedNumbers)); numbersCopy[0].push(300); console.log(nestedNumbers, numbersCopy); // [[1], [2]] // [[1, 300], [2]] // 兩個陣列是獨立的，互不影響！ 缺點：只能套用在拷貝轉成 JSON 格式的物件上，像 function 就沒辦法。 9. Array.concat (Shallow copy) 內建的陣列操縱方法 Array.concat ．淺拷貝 Array.concat： 合併 a 陣列與 b 陣列的值。 [1, 2, 3].concat(4); // [1, 2, 3, 4] [1, 2, 3].concat([4, 5]); // [1, 2, 3, 4, 5] 如果是給一個空陣列作為引數，淺拷貝會直接中斷（return）。 [1, 2, 3].concat(); // [1, 2, 3] [1, 2, 3].concat([]); // [1, 2, 3] 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 10. Array.from (Shallow copy) 內建的陣列操縱方法 Array.from ．淺拷貝 Array.from：可以將任何可迭代的物件轉成陣列。因為陣列本身就是物件的一種，所以只要給一個陣列作為引數，就會回傳一個淺拷貝。 const numbers = [1, 2, 3]; const numbersCopy = Array.from(numbers); // [1, 2, 3] 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。","link":"/javascript-deep-copy-swallow-copy/"},{"title":"在 JavaScript 中，Var、Let、Const 的差異？","text":"Var 露出去的變數 i for(var i = 0; i&lt;10; i++) { console.log(i) } console.log(i) // 10 感謝 Reynold Cheng 於 2020/10/01 熱心指正第一個範例，結果為 10。 function scope：function 外就存取不到變數 i function printing(){ for(var i = 0; i&lt;10; i++) { console.log(i) } } printing() console.log(i) // Uncaught ReferenceError: i is not defined IIFE (immediately invoked function expression) 立即執行函式：將變數 i 鎖在 function scope 中 (function (){ for(var i = 0; i&lt;10; i++) { console.log(i) } })() Let block scope：block {} 外就存取不到變數 i for(let i = 0; i&lt;10; i++) { console.log(i) } console.log(i) // Uncaught ReferenceError: i is not defined Const 如果在一段程式碼中，確定不會更動變數的值，就使用 const 來宣告變數。 const dog={ age: 3 } dog.age = 5 dog = { name: 'biko'} // Uncaught TypeError: Assignment to constant variable. 可以改變物件下的屬性（property），而不能重新把變數 dog 指向一個新的物件。 Reference Javascript variables; should you use let, var or const?","link":"/differences-among-var-let-const/"},{"title":"Arrow function 解決了什麼問題？","text":"目的 將 this 鎖在 function 當中。 為了取代舊有的.bind()（.bind() 會綁定 this 到指定的 obj）。 適合情境 只要 function 內的 this 還要再往下傳的時候，就適合使用 arrow function。 Rules Rule 1 在 ES5 function 寫法時，this 指誰，要看被呼叫時是誰呼叫他。 Rule 2 箭頭函數當中的 this 是定義時的對象，而不是使用時的對象。arrow function 中沒有 this，this 指誰要看他身處在的環境 (function scope) 當中 this 指向誰 (回到 Rule 1)，也就是一定要有人在外層接起來，沒有接起來就會指向 global object，瀏覽器的執行環境中稱為 window。 Example let BMI = { test: function () { console.log('BMI.test', this) // BMI，由被呼叫時看是誰叫的。 function testtest () { console.log('BMI.test &gt; testtest(ES5)', this) // 由被呼叫時看是誰叫的。testtest() 找不到是誰叫的 // 指向 window。 // 若要傳遞 this，解決方式是 // 在 BMI.test()設一個變數把 this 接起來 // eg. let that = this } let testtest2 = () =&gt; { console.log('BMI.test &gt; testtest2(ES6)',this) // 指向 BMI =&gt; 被鎖住哩！ } testtest() testtest2() }, test2: () =&gt; { console.log('BMI.test2', this) // 指向 window，arrow function 沒有 this， // 往上一層又找不到，往上持續找到最上層是 window。 // 這樣的寫法，原本就是指向 window。 } } BMI.test() BMI.test2() 參考： MDN - 箭頭函式 PJ - [筆記] 談談 JavaScript 中的 “this” 和它的問題 Kuro - What’s THIS in JavaScript ? [中]","link":"/this-arrow-function-in-javascript/"},{"title":"千人活動的備餐原則 - 根據 kerl lin 大大文章所整理的待辦清單","text":"完全參考至 （千人活動的便當該如何準備？——Karl Lin）並加以整理，詳情可以連結至原作者文章。 什麼都行，最重要的是：絕對不能「食物中毒」！ 辦活動訂午餐，可以不好吃，可以又貴份量又少吃不飽，可以剩一堆廚餘，但**絕對絕對不能食物中毒**。 避免食物中毒的措施 謹慎挑選便當業者。 不要太早送到活動場地。 讓便當業者自己送餐（因為他們知道不同天氣下怎樣送便當能避免變質）。 不要使用 UberEATS 或 LaLaMove（因為他們不是食物外送專家）。 每種口味的便當預留一份放冰箱（因為如果最後食物中毒，至少有保留證據能釐清問題是便當業者或是活動方）。 食物中毒的可能因素 前：在廚房製作時就出問題。 中：運送過程中，天氣太熱造成變質。 後：過早送來活動會場，活動場地保存過程有問題。 挑選便當業者的原則 並不是隨便挑一間喜歡或吃過的餐廳、自助餐就可以！ 有沒有大量出餐的經驗？ 有經驗的業者會： 食安有保障：備料過程、食材選擇都會特別注意。 送餐準時：有大量出餐過，才抓得準時間。 實際去廚房逛過一次了嗎？ 如果不知道什麼是「好」廚房，先去看復興空廚、原味廚房、糧心廚房這類業界知名的，以它們作為標準。 是否有相關食安證照呢？ 例如：HACCP。 飲食屬性 除了「食物中毒」，並屏除「挑食狀況」以外，有些會因為身體或宗教因素而不能吃「海鮮、蠶豆」等食物，所以仔細觀察大型活動的便當內容物，通常不會看到「海鮮、蠶豆、豬肉」等食材。找到專業的便當業者，也可以稍微提醒他們一下。 吃飽、吃得開心的小訣竅 觀察活動參與者的「年齡、性別分布」，提供給餐飲業者參考。 會影響份量跟口味控制。 查看天氣預報。 天氣很熱，誰想吃咖哩？ 怎麼得知參與者有沒有吃開心？ 計算每次活動的「廚餘重量」。 藉此知道會眾有沒有把便當吃光光，累積個幾場活動就有比較、有經驗了。 餐點數量 辦活動就會有報到率的問題，所以量的控制注意： 根據過去活動或類似活動的報到率來計算便當數量。 千萬不要一千人報名，活動就訂一千份，一定會多出一堆。 多日活動：第一天和第二天報到率通常不同。 規定「幾點前報到才要便當吃」的措施。 提升報到率，避免便當剩餘浪費。 通常便當業者會接受，活動當天某時間點前修改 N% 的便當量，詢問業者能接受的「修改時間點」、「修改比例範圍」。 準備好「如果少訂（人數多於便當數量）」的備案。 某個時間點之後，開放「吃第二個便當」。 如果數量有多，可以解決便當剩餘浪費。 其他 如果便當真的多了太多，除了丟掉以外，有沒有其他處理方式？ 假設是在學校辦活動，可以直接敲宿舍同學拿免費便當； 或是聯絡社福機構？ 也要事先安排好人力來處理這件事。 餐飲是件很專業的事情，這邊提到的只是一小部分！ 放餐點的流程、 收廚餘的動線安排、 下午茶的時段和擺盤，背後都有許多眉角 更重要的並非條列式的一項項背起來，而是「細心、同理心、觀察力」。","link":"/meal-box-preperation-for-big-activity/"},{"title":"關於 Webpack，它是什麼？能夠做什麼？為什麼？怎麼做？— freeCodeCamp 的筆記","text":"關於 Webpack Webpack 是什麼？ 它是一個「打包工具」。將眾多模組與資源打包成一包檔案，並編譯我們需要預先處理的內容，變成瀏覽器看得懂的東西，讓我們可以上傳到伺服器。 前端日新月異，我們寫的內容已不只是寫 HTML、CSS、JavaScript 單純的檔案。前端出現了許多預處理工具及框架，預處理工具如 PUG、SASS、Babel；框架如 Vue、React。不過瀏覽器並看不懂我們寫的預處理內容，每每都需要透過編譯才能使用，也因此出現了自動化工具，Webpack、Gulp、Grunt、Parcel、Browserify…等。 Webpack 能夠做什麼？為什麼？ 適合用在大型的應用程式。因為大型的應用程式需要管理眾多不同類型的檔案，使用起來相對有感。 打包（Bundle）多個 .js 檔案成單一檔案。 你可以寫模組化的 JavaScript，你不再需要在 HTML 中引入每個 JavaScript 檔案（&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;），如果有眾多的 .js 檔案，可以透過 Webpack 來設定。 使用 NPM Packages 撰寫 JavaScript ES6 或以上 需要 babel 協助轉譯 最小化、優化程式碼 編譯 LESS 或 SCSS 成 CSS 使用 HMR（Hot Module Replacement） 包含任何類型的檔案到 JavaScript CommomJS、AMD、ES6 Modules、CSS、Images、JSON、Coffeescript、LESS 更多．．．． 安裝 先確定有沒有安裝 node： node -v 初始化 npm，將會在專案中產生 package.json。-y 會將需要回答的問題一次性略過， package.json 中，日後可以修改。 npm init -y .gitigonore 加上 node_modules，避免肥大的模組們被 GIT 追蹤。 node_modules package.json 新增 private 屬性，因為是自己練習用，不希望 NPM 被意外發布，詳情請參考 NPM 官方文件。 &quot;private&quot;: true 安裝 Webpack，--save-dev 表示相依於開發模式而已，而發布為產品時不需要也沒關係： npm install --save-dev webpack webpack-cli 完成後，檢視你的 package.json 的 devDependencies 屬性應該會長這樣： // package.json { &quot;name&quot;: &quot;webpack-demo-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;description&quot;: &quot;透過練習了解 Webpack 解決的事情，並在沒使用 Webpack 的專案試著導入 Webpack。&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: {}, &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/Colt/webpack-demo-app.git&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/Colt/webpack-demo-app/issues&quot; }, &quot;homepage&quot;: &quot;https://github.com/Colt/webpack-demo-app#readme&quot;, &quot;devDependencies&quot;: { // --save-dev 指令裝的套件將會幫我們放到 package.json 的 devDependencies 中 &quot;webpack&quot;: &quot;^4.35.0&quot;, // Webpack 裝好了！ &quot;webpack-cli&quot;: &quot;^3.3.4&quot; // Webpack 裝好了！ } } &quot;scripts&quot; 新增自訂指令 &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack&quot; } 執行 Webpack npm start 直接在 Terminal 執行 npm start 會拋出一個錯誤 ERROR in Entry module not found: Error: Can't resolve './src' in 'your-directory/webpack-demo-app'。發現在 ./src 這個資料夾找不到 index.js，所以在 ./src 這個資料夾下建立 index.js 後再試一次 npm start 看看編譯的狀況。 顯示一個警告，設定檔中的模式參數 mode 未設定，預設值是 production，所以幫你在專案中，產生靜態資料夾 dist： WARNING in configuration The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment. You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ （因為這時還沒有建立設定檔，主要是先試試 Webpack 的預設會如何編譯。） Imports, Exports, &amp; Webpack Modules 可以根據程式的相依函式來設定 ES6 的 import、export： // 將變數 inputsAreValid export export const inputsAreValid = (...input) =&gt; { return input.every(num =&gt; typeof num === &quot;number&quot; &amp;&amp; !isNaN(num)); }; // 其他使用的檔案則可以 import import { inputsAreValid } from &quot;./utils/inputs-are-valid&quot;; index.js 是 Webpack 的進入點，放在專案根目錄（root）。 原本的程式碼在寫完後，如果以功能區分會拆成眾多檔案，那麼在 HTML 引入時會因為順序不同而影響執行，所以要導入 Webpack 讓我們可以把心力放在寫程式上面。 將程式碼模組化之後，只要在程式碼中，確定你需要的變數或 function 有 export，並且在需要的地方 import，自此就可以不需擔心 .js 檔案在 HTML 中引入的順序囉！ 解決了以下問題： 若使用外部 Library，不容易辨識哪些程式碼相依於外部 Library 相依的程式如果順序錯誤就會造成程式執行異常 相依的程式若是引入卻未使用，瀏覽器還是得無意義地強制加載 設定 在專案根目錄建立 webpack.comfig.js。 // webpack.comfig.js const path = require(&quot;path&quot;); // 引入 path 來解決巢狀引入路徑問題 module.exports = { mode: &quot;development&quot;, // 設定開發模式就不會 minify devtool: &quot;none&quot;, // 編譯後的程式碼不會有 eval 這樣的用法 entry: &quot;./src/index.js&quot;, output: { filename: &quot;hello.js&quot;, // 編譯後的檔名 path: path.resolve(__dirname, &quot;your-directory-name&quot;) // 編譯後要放在哪個資料夾 } }; 把指令更改為：以後 npm start 要根據我的 Webpack 設定檔辦事囉！ // package.json { &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack --config webpack.comfig.js&quot; } } Loaders: CSS SASS 什麼是 Loader？ 在使用 Webpack 時，我們可以引入 .js以外的其他類型檔案，而 Loader 是 Webpack 中強大的工具，用來幫我們預處理你引入的各種類型檔案。詳情請參考官方文件 - Loaders。 建立一個 .css 檔案 /* main.css */ body { background: #009688; } 安裝 style-loader 與 css-loader npm install --save-dev style-loader css-loader 新增 css-loader 規則 // add it to webpack.config.js module: { rules: [ { test: /\\.css$/, // 正則式，$ 用以表示以 .css 結尾的檔案，反斜線是跳脫字元 use: [&quot;style-loader&quot;, &quot;css-loader&quot;] } ]; } css-loader：先取得你的 CSS 樣式，把它變成 JavaScript。 style-loader：將轉譯的 JavaScript 變成真正的 CSS 樣式，透過 &lt;style&gt; tag 插入你的 DOM tree。 而 webpack 編譯時，從陣列的最後一個開始往前執行，了解流程之後，之後 Loader 的使用順序是有差異的喔！ 先寫 style-loader，再來才是 css-loader。 可以直接引入 CSS 囉！ // index.js import { mainCSS } from &quot;./main.css&quot;; 以下筆記待續。 Cache Busting and Plugins 切割開發版本與產品版本 Html-loader, File-loader 以及乾淨的 webpack 多個 Entrypoints 及 Vendor.js 提取 CSS，將 HTML/CSS/JS 最小化 主要 Reference 影片教學 FreeCodeCamp 教學 @youtube 時間軸大綱 ⌨️ (0:00:00) What Even Is Webpack?? ⌨️ (0:08:12) Installing and Running Webpack and Webpack-CLI ⌨️ (0:22:18) Imports, Exports, &amp; Webpack Modules ⌨️ (0:29:58) Configuring Webpack ⌨️ (0:38:57) Loaders, CSS, &amp; SASS ⌨️ (0:53:55) Cache Busting and Plugins ⌨️ (1:07:13) Splitting Dev &amp; Production ⌨️ (1:17:13) Html-loader, File-loader, &amp; Clean-webpack ⌨️ (1:28:17) Multiple Entrypoints &amp; Vendor.js ⌨️ (1:34:45) Extract CSS &amp; Minify HTML/CSS/JS 其他 Reference Ｗ ebpack 官網 Webpack Tutorial 繁體中文 Gitbook Webpack 教學 (一) ：什麼是 Webpack? 能吃嗎？ Better local require() paths for Node.js","link":"/what-is-webpack/"},{"title":"Bulma 介紹及用法，透過 cheatsheet 快速閱讀文件","text":"Bulma 講到 CSS Framework，應該無人不知 Bootstrap。最近在 State of CSS 2019 的問卷結果中看到全球 CSS 使用數據，包含知名度、感興趣程度及使用滿意度，Bootstrap 的滿意度極低，而 Bulma 在使用滿意度算表現得很好，高達 74%，居於第二名，滿意度的第一名是 Taiwlind。CP 值好高，所以想來試試看 Bulma！ 知名度：**50%**｜ (全部受測數 - 從沒聽過的人) / 全部受測數 感興趣：**41%**｜有興趣 / (有興趣 + 沒興趣) 滿意度：**74%**｜想再使用 / (想再使用 + 不想再使用) 本篇文章純粹紀錄如何使用，方便自己日後忘記可以快速上手，不會與其他 CSS Framework 進行比較唷。 Bulma 的 Responsive Web Design 跟 Bootstrap 4 一樣，也是利用 flexbox 來實現的，這篇記錄的 Bulma 版本是 0.7.5。 tl;dr 感想、使用心得 一開始光看文件不太好找到需要的元件，不過原始碼和成果的對照還算清楚，超輕量！使用下來，安排網頁架構時，元素不影響權重很棒，也能自定義自己的色系，一律採用一個 component 組合搭配 modifiers，整體使用上也還算直覺，所以上手得快。 安裝方法 依你的情境選擇你想怎麼引入，詳見 官方文件 或 GitHub。 CDN 到 cdnjs 這個 CDN 平台選擇版本，並引入至 HTML 中。 &lt;link rel=&quot;stylesheets&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css&quot; /&gt; 本地引入 至 GitHub Repo 下載 CSS 檔案至本地的專案資料夾中，並引入至 HTML 中。src 中的./ 表相對路徑。 &lt;link rel=&quot;stylesheets&quot; src=&quot;./your-directory/bulma.min.css&quot; /&gt; NPM / Yarn npm install bulma-start 或是 yarn add bulma-start NPM package 有包含哪些項目及相依套件請參考：What’s included。 注意： 要使用 bulma 中有含 icon 的輪子，要記得引入 Font Awesome 5。 要宣告 HTML5 的檔案類型，&lt;!DOCTYPE html&gt;，以利正常顯示。 要宣告自適應的 viewport 宣告，以利正常顯示。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; 概覽 類別：只有 class，純粹架構 HTML 時不會影響樣式。 genertic.sass：定義頁面基本樣式。 使用 .content 類別作為文字內容的容器，就可以輕鬆的使用 modifiers，套用 tag 樣式。 &lt;p&gt; paragraphs &lt;ul&gt; &lt;ol&gt; &lt;dl&gt; lists &lt;h1&gt; to &lt;h6&gt; headings &lt;blockquote&gt; quotes &lt;em&gt; and &lt;strong&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt; tables 模組化：有 39 個獨立的 sass 檔案，可單獨引入。 如果你想使用網格系統，只要引入： @import &quot;bulma/sass/utilities/_all.sass&quot; @import &quot;bulma/sass/grid/columns.sass&quot; &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;5&lt;/div&gt; &lt;/div&gt; 如果你想使用 buttons，只要引入，就可以使用這些 .button 及 modifers： .is-active .is-primary, .is-info, .is-success… .is-small, .is-medium, .is-large .is-outlined, .is-inverted, .is-link .is-loading, [disabled] @import &quot;bulma/sass/utilities/_all.sass&quot; @import &quot;bulma/sass/elements/button.sass&quot; &lt;button class=&quot;button&quot;&gt;Button&lt;/button&gt; &lt;button class=&quot;button is-primary&quot;&gt;Primary button&lt;/button&gt; &lt;button class=&quot;button is-large&quot;&gt;Large button&lt;/button&gt; &lt;button class=&quot;button is-loading&quot;&gt;Loading button&lt;/button&gt; 自適應：預設是「垂直」佈局。 行動裝置為優先、垂直式閱讀設計。可以在 .columns及 .level 加上 .is-mobile強制改成水平佈局。 顏色：10 種顏色及 8 個層級的陰影。 可以透過變數去自定義你的。設定：.is-$color，比如說 .is-primary 或 .is-dark。 functions：提供 3 個 functions 去動態定義「值」、「顏色」。 powerNumber($number, $exp)：計算相對暴露值，回傳數字。（目前尚不理解！） colorLuminance($color)：計算亮度該是 dark 還是 light，回傳介於 0 與 1 之間的值（light: &gt; 0.5, dark: &lt;= 0.5，十進位）。 findColorInvert($color)：根據顏色的明亮度去計算該是黑色rgba(#000, 0.7)還是白色#ffffff。確保按鈕上文字搭配背景顏色後的可讀性。 mixins：提供 arrow($color)、clearfix、loader、overflow-touch…等可使用，詳見文件。 我的 Cheatsheet 不是完整官方文件的 cheatSheet，由於一開始看 Bulma 不熟悉，所以串得不是很起來，透過整理 bulma 教學影片去熟悉 bulma 的架構與設計，這時搭配文件非常好上手了～ 文字內容 Context 標題 Heading：使用 .title。 使用 .title 搭配 modifiers。 &lt;h1 class=&quot;title is-1&quot;&gt;Hello Askie&lt;/h1&gt; &lt;h2 class=&quot;title is-2&quot;&gt;Hello Askie&lt;/h2&gt; &lt;h3 class=&quot;title is-3&quot;&gt;Hello Askie&lt;/h3&gt; &lt;h4 class=&quot;title is-4&quot;&gt;Hello Askie&lt;/h4&gt; &lt;h5 class=&quot;title is-5&quot;&gt;Hello Askie&lt;/h5&gt; &lt;h6 class=&quot;title is-6&quot;&gt;Hello Askie&lt;/h6&gt; 內容 Content：使用 .content。 使用 .content 搭配 modifiers。 &lt;p&gt; paragraphs &lt;ul&gt; &lt;ol&gt; &lt;dl&gt; lists &lt;h1&gt; to &lt;h6&gt; headings &lt;blockquote&gt; quotes &lt;em&gt; and &lt;strong&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt; tables modifiers sizes：3 級。 &lt;p class=&quot;content is-small&quot;&gt;Hello Askie and Hello World!&lt;/p&gt; &lt;p class=&quot;content is-medium&quot;&gt;Hello Askie and Hello World!&lt;/p&gt; &lt;p class=&quot;content is-large&quot;&gt;Hello Askie and Hello World!&lt;/p&gt; 按鈕 Buttons colors：11 種顏色，可搭配 sizes 使用。 &lt;!-- buttons and colors --&gt; &lt;button class=&quot;button&quot;&gt;Button&lt;/button&gt; &lt;button class=&quot;button is-white&quot;&gt;Button&lt;/button&gt; &lt;button class=&quot;button is-light&quot;&gt;Button&lt;/button&gt; &lt;button class=&quot;button is-dark&quot;&gt;Button&lt;/button&gt; &lt;button class=&quot;button is-black&quot;&gt;Button&lt;/button&gt; &lt;button class=&quot;button is-link&quot;&gt;Button&lt;/button&gt; &lt;!-- links: like a button style --&gt; &lt;a href=&quot;&quot; class=&quot;button is-primary&quot;&gt;Primary&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button is-info&quot;&gt;Info&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button is-success&quot;&gt;Success&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button is-warning&quot;&gt;Warning&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button is-danger&quot;&gt;Danger&lt;/a&gt; .is-outlined外框按鈕 &lt;!-- outline --&gt; &lt;a href=&quot;&quot; class=&quot;button is-danger is-outlined&quot;&gt;Danger&lt;/a&gt; .is-inverted反相按鈕 &lt;!-- inverted --&gt; &lt;a href=&quot;&quot; class=&quot;button is-danger is-inverted&quot;&gt;Danger&lt;/a&gt; 按鈕狀態 &lt;a href=&quot;&quot; class=&quot;button is-hovered&quot;&gt;Hovered&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button is-focused&quot;&gt;Focused&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button is-active&quot;&gt;Active&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button is-loading&quot;&gt;Loading&lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;button&quot; disabled&gt;Disabled&lt;/a&gt; 區塊 Boxes! &lt;div class=&quot;box&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;Hello world&lt;/h1&gt; &lt;p&gt;lorem ipsum&lt;/p&gt; &lt;/div&gt; 通知 Notifications &lt;div class=&quot;notification is-success&quot;&gt; &lt;button class=&quot;delete&quot;&gt;&lt;/button&gt; lorem ipsum &lt;/div&gt; 標籤 Tags &lt;span class=&quot;tag&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;tag is-black&quot;&gt;black&lt;/span&gt; &lt;span class=&quot;tag is-danger is-medium&quot; &gt;Danger &lt;button class=&quot;delete&quot;&gt;&lt;/button &gt;&lt;/span&gt; 訊息 Messages &lt;article class=&quot;message is-primary&quot;&gt; &lt;header class=&quot;message-header&quot;&gt;&lt;p&gt;About Us&lt;/p&gt;&lt;/header&gt; &lt;div class=&quot;message-body&quot;&gt;Holly yes!!&lt;/div&gt; &lt;/article&gt; 導覽列 Navigations &lt;nav class=&quot;nav&quot;&gt; &lt;!-- 導覽列容器 --&gt; &lt;div class=&quot;nav-left&quot;&gt; &lt;!-- 對齊方式：置左 --&gt; &lt;a href=&quot;&quot; clas=&quot;nav-item&quot; &gt;&lt;!-- 元素 --&gt; &lt;h1 class=&quot;title is-4&quot;&gt;Askie Lin&lt;/h1&gt; &lt;!-- 標題 --&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-right nav-menu&quot;&gt; &lt;!-- 對齊方式：置右，是一個選單 --&gt; &lt;a href=&quot;&quot; clas=&quot;nav-item&quot;&gt;A&lt;/a &gt;&lt;!-- 元素 --&gt; &lt;a href=&quot;&quot; clas=&quot;nav-item&quot;&gt;B&lt;/a &gt;&lt;!-- 元素 --&gt; &lt;a href=&quot;&quot; clas=&quot;nav-item&quot;&gt;C&lt;/a &gt;&lt;!-- 元素 --&gt; &lt;/div&gt; &lt;/nav&gt; Hero &lt;section class=&quot;hero is-warning&quot;&gt; &lt;!-- hero 容器 --&gt; &lt;div class=&quot;hero-body&quot;&gt; &lt;!-- hero 主體 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 不一定需要，範例的情境適合用一個 container 包起來 --&gt; &lt;h1 class=&quot;title&quot;&gt;Hello World&lt;/h1&gt; &lt;h2 class=&quot;subtitle&quot;&gt;I am Askie Lin.&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 卡片 Cards &lt;section class=&quot;card is-warning&quot;&gt; &lt;!-- card 容器 --&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;!-- card 主體 --&gt; &lt;p class=&quot;title&quot;&gt;Hello world, Askie.&lt;/p&gt; &lt;/div&gt; &lt;footer class=&quot;card-footer&quot;&gt; &lt;!-- card 頁尾 --&gt; &lt;p class=&quot;card-footer-item&quot;&gt; &lt;!-- 頁尾元素 --&gt; &lt;span&gt;View on&lt;a href=&quot;&quot;&gt;Twitter&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;p class=&quot;card-footer-item&quot;&gt; &lt;!-- 頁尾元素 --&gt; &lt;span&gt;Share on&lt;a href=&quot;&quot;&gt;Facebook&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;/footer&gt; &lt;/section&gt; 頁數 Pagination 容器使用 .pagination。 功能使用 .pagination-previous 上一頁 / .pagination-next 下一頁。 頁數主體使用 unordered list。 頁數元素使用 .pagination-link，modifiers 有無法點擊 disabled 及目前所在頁數 .is-current。 &lt;nav class=&quot;pagination&quot;&gt; &lt;!-- pagination 容器 --&gt; &lt;a href=&quot;&quot; class=&quot;pagination-previous&quot; disabled&gt;Previous&lt;/a &gt;&lt;!-- 上一頁 --&gt; &lt;a href=&quot;&quot; class=&quot;pagination-next&quot; disabled&gt;Next Page&lt;/a &gt;&lt;!-- 下一頁 --&gt; &lt;ul&gt; &lt;!-- pagination 主體 --&gt; &lt;li&gt;&lt;a href=&quot;&quot; class=&quot;pagination-link is-current&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;!-- 目前在這一頁 --&gt; &lt;li&gt;&lt;a href=&quot;&quot; class=&quot;pagination-link&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot; class=&quot;pagination-link&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; Level：協助水平對齊，適合刻一些小巧的元件放在裡面 容器使用 .level。 方向使用 .level-left/ .level-right。 元素使用 .level-item。 &lt;section class=&quot;level&quot;&gt;&lt;!-- level 容器 --&gt; &lt;div class=&quot;level-left&quot;&gt;&lt;!-- 水平置左 --&gt; &lt;p class=&quot;level-item&quot;&gt;&lt;a&gt;&lt;strong&gt;All&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- level 元素 --&gt; &lt;p class=&quot;level-item&quot;&gt;&lt;a&gt;Published&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;level-item&quot;&gt;&lt;a&gt;Draft&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;level-item&quot;&gt;&lt;a&gt;Deleted&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;level-item&quot;&gt;&lt;a class=&quot;button is-primary&quot;&gt;All&lt;/a&gt;&lt;/p&gt;&lt;!-- 按鈕形狀的元素 --&gt; &lt;/div&gt; &lt;div class=&quot;level-right&quot;&gt;&lt;!-- 水平置右 --&gt; &lt;p class=&quot;level-item&quot;&gt;&lt;!-- level 元素 --&gt; &lt;div class=&quot;field&quot;&gt;&lt;!-- 表單區域 --&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; placeholder=&quot;Search...&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/p&gt; &lt;/div&gt; &lt;/section&gt; 表單 Forms 使用.field 作為每個元素的區隔。 Input &lt;form&gt; &lt;div class=&quot;field&quot;&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=&quot;label&quot;&gt;Name&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; placeholder=&quot;Eneter Name&quot; /&gt;&lt;!-- 表單 text 元素 --&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=&quot;label&quot;&gt;Name&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;input type=&quot;text&quot; class=&quot;input is-success&quot; placeholder=&quot;Eneter Name&quot; /&gt;&lt;!-- 配合 modifier --&gt; &lt;/div&gt; &lt;/form&gt; select &lt;form&gt; &lt;div class=&quot;field&quot;&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=&quot;label&quot;&gt;Select&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;p class=&quot;control&quot;&gt; &lt;span class=&quot;select&quot;&gt; &lt;select&gt; &lt;option&gt;開始選吧！&lt;/option&gt; &lt;option&gt;簡單&lt;/option&gt; &lt;option&gt;中等&lt;/option&gt; &lt;option&gt;困難&lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/form&gt; textarea &lt;form&gt; &lt;div class=&quot;field&quot;&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=&quot;label&quot;&gt;Textarea&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;p class=&quot;control&quot;&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;textarea class=&quot;textarea&quot; placeholder=&quot;Type somthing...&quot;&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;/div&gt; &lt;/form&gt; 使用 icons： &lt;form&gt; &lt;!-- example 1 --&gt; &lt;div class=&quot;field has-addons&quot;&gt; &lt;!-- 表單元件的容器 --&gt; &lt;p class=&quot;control&quot;&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; placeholder=&quot;Eneter Keywords...&quot; /&gt;&lt;!-- 表單 text 元素 --&gt; &lt;/p&gt; &lt;p class=&quot;control&quot;&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;a href=&quot;&quot; class=&quot;button is-info&quot;&gt;搜尋&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;!-- example 2 --&gt; &lt;div class=&quot;field has-addons&quot;&gt; &lt;!-- 表單元件的容器 --&gt; &lt;p class=&quot;control&quot;&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;span class=&quot;select&quot;&gt; &lt;select&gt; &lt;option&gt;新台幣&lt;/option&gt; &lt;option&gt;美金&lt;/option&gt; &lt;option&gt;日圓&lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;/p&gt; &lt;p class=&quot;control&quot;&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; placeholder=&quot;填寫金額&quot; /&gt;&lt;!-- 表單 text 元素 --&gt; &lt;/p&gt; &lt;p class=&quot;control&quot;&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;a href=&quot;&quot; class=&quot;button is-info&quot;&gt;送出&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/form&gt; 表格 Tables modifiers，可以交互使用 .table 容器 .is-striped：灰白相間的表格。 .is-bodered：邊框的表格。 .is-narrow：窄一點的表格。 tr .is-selected：選擇中的列。 &lt;table class=&quot;table &quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓氏&lt;/th&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;星座&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;林&lt;/td&gt; &lt;td&gt;ＯＯ&lt;/td&gt; &lt;td&gt;牡羊座&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王&lt;/td&gt; &lt;td&gt;ＸＸ&lt;/td&gt; &lt;td&gt;射手座&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 網格系統 Grid System 純粹的網格，不論裡面有「幾格」都會自動排好： &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;First Column&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Second Column&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Third Column&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; 十二網格系統，搭配 modifiers .is-$number： &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-2&quot;&gt;&lt;p class=&quot;notification&quot;&gt;2 Column&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column is-8&quot;&gt;&lt;p class=&quot;notification&quot;&gt;8 Column&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column is-2&quot;&gt;&lt;p class=&quot;notification&quot;&gt;2 Column&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; 某一格佔據「四分之三」，剩下的自動排好： &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-three-quarters&quot;&gt; &lt;p class=&quot;notification&quot;&gt;四分之三&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; 某一格佔據「三分之二」，剩下的自動排好： &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-two-thirds&quot;&gt;&lt;p class=&quot;notification&quot;&gt;三分之二&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; 某一格佔據「一半」，剩下的自動排好： &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-half&quot;&gt;&lt;p class=&quot;notification&quot;&gt;50%&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;column&quot;&gt;&lt;p class=&quot;notification&quot;&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;","link":"/intro-of-bulma-css-framework/"},{"title":"CSS Modules 在 Vue 的用法？和 CSS scoped 分別的優勢？","text":"Demo(本頁開啟) | 我的設計稿 撰寫 CSS 的過程中，都會搭配 SASS 預處理器，之前一直有聽過 CSS IN JS，不知該如何寫起？剛好今年六角學院的前端精神時光屋切了第一週的版（蕃茄鐘），想說用 Vue 來練習 CSS Modules，其實是看到 Vue Loader 官方文件的介紹，動手做做看，再 google 大大們的文章吸收一下日月精華，整理在此。 CSS IN JS（JavaScript） 大家都知道，其實 CSS 一直以來都不算是個程式語言，只能用來拿來描述網頁的長相，為了讓 CSS 也可以透過簡單的程式方法來解決一些維護、跨瀏覽器前綴及作用域的問題，出現了 LESS、SASS、Stylus、PostCSS 再到最近的 CSS IN JS。CSS IN JS 是 CSS 近年來最大的發展之一，倚靠 JavaScript 強大的力量，讓開發者終於可以透過 JavaScript 來管理 CSS。 以下是今年 CSS IN JS 的排名： 參考來源：State of CSS 2019 CSS Modules 優勢？解決什麼事？ CSS Modules 顧名思義就是希望能真正將 CSS 模組化，其非常單純，透過 webpack 幫我們自動化，動態產生 class 名稱，解決以下問題，又可以和其他預處理器一同使用，如 SASS！ 解決 BEM 要解決的問題： 降低 CSS 權重（優先級）也就是說，降低了區塊與區塊之間的相依性 新增了後綴，解決了「Global 作用域」的問題 但是繼續保持模組化、可重複使用的優點！ 如 Vue 中，CSS scoped 已經可以隔開作用域，此時就會有複用 我使用 BEM 已經很習慣了，可是人性就是懶惰，如果不是自己懶，就是隊友懶，以手動的做法來說，怎麼樣都還是有隱性問題會藏在專案中，不如交給自動化。 如何使用 CSS Modules？（Vue and React） Vue 我目前 Vue Cli 使用的版本是 3.9.2，已經有整合 CSS Modules 到開發環境中，不需再另外設定。他會在 CSS modules 啟用後，在 computed 產生一個屬性。 查看版本：vue --version 與 CSS scoped 最大不同，是 CSS scoped 雖然也會在 class 名稱加上一個後綴屬性，將元件內 CSS 指定其作用域，可是他並不能完全避免衝突。 vue 單檔內的使用方法： 將 &lt;style&gt; 加上 module 屬性： 是單數喔！注意不是 modules，因為我就加錯過，新手會犯的錯，找半天。 &lt;style module&gt; .title { font-size: 2rem; } &lt;/style&gt; 在樣板 &lt;template&gt;裡引用，需要 v-bind 上 class： &lt;!-- 單純的 class 名稱 --&gt; &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;$style.title&quot;&gt;Hello world, askie.&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- 有連字號的 class 名稱 --&gt; &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;$style['my-title']&quot;&gt;Hello world, askie.&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; 搭配 Vue Class Binding：官方範例 &lt;p :class=&quot; { [$style.red]: isRed }&quot;&gt; 是紅色的嗎？你決定！ &lt;/p&gt; &lt;p :class=&quot; [$style.red, $style.bold]&quot;&gt; 我是紅色的字，並且是粗體。 &lt;/p&gt; keyframes 動畫名稱必須先寫： animation: pop 0.5s; // =&gt; animation: p_nfriono0d3eG_08_1 1s; 如果，你把動畫名稱寫在「後面」就會解析失敗： animation: 0.5s pop; // =&gt; animation: 1s :local(pop); 獨立檔案作法：將獨立的 CSS 檔案作為 CSS Modules 載入 import styles from './styles.module.scss'; 其他設定 可以參考Vue Loader 官方文件、Vue-js-與-CSS-Modules - Kuro 大大，幫助了我快速理解 CSS Modules 起源、目的、解決了什麼事，以及如何使用。謝謝～ React: 本身沒有寫 React，謹將範例列在此，以供查閱（範例來源） 區域選擇器：一個一個單獨選你的 class import styles from './ScopedSelectors.css'; import React, { Component } from 'react'; export default class ScopedSelectors extends Component { render() { return ( &lt;div className={styles.root}&gt; &lt;p className={styles.text}&gt;Scoped Selectors&lt;/p&gt; &lt;/div&gt; ); } } // ScopedSelectors.css .root { border-width: 2px; border-style: solid; border-color: #777; padding: 0 20px; margin: 0 6px; max-width: 400px; } .text { color: #777; font-size: 24px; font-family: helvetica, arial, sans-serif; font-weight: 600; } 全域選擇器 import styles from './GlobalSelectors.css'; import React, { Component } from 'react'; export default class GlobalSelectors extends Component { render() { return ( &lt;div className={styles.root}&gt; &lt;p className='text'&gt;Global Selectors&lt;/p&gt; &lt;/div&gt; ); } } .root { border-width: 2px; border-style: solid; border-color: brown; padding: 0 20px; margin: 0 6px; max-width: 400px; } .root :global .text { color: brown; font-size: 24px; font-family: helvetica, arial, sans-serif; font-weight: 600; } 組成 Compose，概念近於 SASS extend 使用 composes 這個屬性，去引入你的共用的 CSS 模組。 // 動畫範例 import styles from './ScopedAnimations.css'; import React, { Component } from 'react'; export default class ScopedAnimations extends Component { render() { return ( &lt;div className={styles.root}&gt; &lt;div className={styles.ball} /&gt; &lt;/div&gt; ); } } // ScopedAnimations.css .root { padding: 20px 10px; } .ball { composes: bounce from 'shared/styles/animations.css'; width: 40px; height: 40px; border-radius: 20px; background: rebeccapurple; } // shared/styles/animations.css @keyframes bounce { 33% { transform: translateY(-20px); } 66% { transform: translateY(0px); } } .bounce { animation: bounce 1s infinite ease-in-out; }","link":"/vue-difference-between-css-modules-and-css-scoped/"},{"title":"五個小技巧讓你寫出更好的 JavaScript 條件語句（翻譯）","text":"1. 使用 Array.includes 來處理多重條件 // 原始寫法 function test(fruit) { // 條件語句 if (fruit === &quot;apple&quot; || fruit === &quot;strawberry&quot;) { console.log(&quot;red fruit&quot;); } } 乍看之下，寫法沒什麼錯誤。可是當我們有更多紅色水果的選項時，如 cherry（櫻桃）和 cranberries（蔓越莓），難道我們要增加更多的 || 邏輯運算子來判斷？ 我們用 Array.includes 來改寫一次上面的判斷式： // 改寫後 function test(fruit) { // 將選項提取出來，放入陣列當中 const redFruits = [&quot;apple&quot;, &quot;strawberry&quot;, &quot;cherry&quot;, &quot;cranberries&quot;]; if (redFruits.includes(&quot;apple&quot;)) { console.log(&quot;red fruit&quot;); } } 將選項、可能的答案提取出來，放入陣列 red fruits 當中。這樣寫的話，程式碼看起來更加簡潔。 2. 減少巢狀，儘早回傳（ return） 這裏使用上面的程式碼內容來接續下面的範例，新增兩個條件。 如果參數 fruit 沒有值，回傳錯誤（ error）。 如果數量超過 10 的話，印出一個訊息。 // 原始寫法，寫法一 function test(fruit, quantity) { const redFruits = [&quot;apple&quot;, &quot;strawberry&quot;, &quot;cherry&quot;, &quot;cranberries&quot;]; // 判定一：fruit 必須有值 if (fruit) { // 判定二：fruit 必須是紅色的 if (redFruits.includes(fruit)) { console.log(&quot;red fruit&quot;); if (quantity &gt; 10) { // 判定三：fruit 數量必須大於 10 console.log(&quot;big quantity&quot;); } } } else { throw new Error(&quot;No fruit!&quot;); } } // 測試結果 test(null); // 錯誤：沒有水果的值！ test(&quot;apple&quot;); // 印出 red fruit test(&quot;apple&quot;, 20); // 印出 red fruit、big quantity 以上程式碼，已經加入了： 1 個 if/else 的條件判斷，篩選掉無效的內容。 3 個巢狀條件判斷（判定一、判定二、判定三）。 對我個人而言，有一個基本通則，那就是「減少巢狀，儘早回傳」： // 改寫後，寫法二 function test(fruit, quantity) { const redFruits = [&quot;apple&quot;, &quot;strawberry&quot;, &quot;cherry&quot;, &quot;cranberries&quot;]; // 判定一：無效的值就直接跳出程式，拋出 error if (!fruit) throw new Error(&quot;No fruit!&quot;); // 判定二：fruit 必須是紅色的 if (redFruits.includes(fruit)) { console.log(&quot;red fruit&quot;); // 判定三：fruit 數量必須大於 10 if (quantity &gt; 10) { console.log(&quot;big quantity&quot;); } } } 改寫程式碼後，現在只有一層的巢狀判斷式。尤其當你有很長的判斷條件時，這樣的 Coding Style 很棒（想像一下，你捲軸需要捲到很後面才知道 else 區塊做了什麼處理。難以閱讀，不帥！） 透過轉換判斷式寫法、儘早回傳，可以更進一步的精簡巢狀 if，來看下面 判斷式二 是如何實現的： // 改寫後，寫法三 function test(fruit, quantity) { const redFruits = [&quot;apple&quot;, &quot;strawberry&quot;, &quot;cherry&quot;, &quot;cranberries&quot;]; // 判定一：無效的值就直接跳出程式，拋出 error if (!fruit) throw new Error(&quot;No fruit!&quot;); // 判定二：fruit 不是紅色的，就直接跳出程式 if (!redFruits.includes(fruit)) return; console.log(&quot;red&quot;); // 判定三：fruit 數量必須大於 10 if (quantity &gt; 10) { console.log(&quot;big quantity&quot;); } } 將判斷式二改成上面的寫法，我們的程式碼就不再這麼「巢」了！假設我們有很長的程式邏輯，並且想要在不滿足條件時中斷程式的進行，這樣的寫法很有效率、易讀。 然而，其實也沒什麼硬性規定該如何寫，一切依使用情境而定，問問自己：「這個寫法套用在目前的狀況有增加可讀性嗎？」 對我來說，我應該會選擇寫法二（只有一層的巢狀結構），原因在於： 程式碼簡潔、直覺，有一層的 if 判定使得邏輯更清晰 反轉程式碼在讀的時候會產生思考流程、增加認知負擔 因此，「減少巢狀，儘早回傳」是原則，但也不要過度使用。 以下有針對這個主題討論的文章及 StackOverflow 討論，有興趣的話可以看一下： Avoid Else, Return Early by Tim Oxley StackOverflow discussion on if/else coding style 3. 函式使用預設值、解構 我猜你應該很熟悉下面這段程式碼，因為我們總是在確認 null / undefined 的值，是的話就給一個預設值。 // 我們可能熟悉的寫法 function test(fruit, quantity) { if (!fruit) return; // 若數量是 falsy value，將預設值設定為 1 const q = quantity || 1; console.log(`We have ${q} ${fruit}!`); } // 測試結果 test(&quot;banana&quot;); test(&quot;apple&quot;, 2); 事實上，在 function 針對參數（parameter） q 先設定預設值，就可以不用在程式碼區塊定義 變數 q。 // 給預設值的寫法 function test(fruit, quantity = 1) { if (!fruit) return; console.log(`We have ${q} ${fruit}!`); } // 測試結果 test(&quot;banana&quot;); test(&quot;apple&quot;, 2); 更簡單、直覺了不是嗎？記得函式都可以設定每個參數的預設值，所以我們也可以幫參數 fruit 設定預設值，如 function test(fruit = 'unknown', quantity = 1)。 那假設 fruit 是物件怎麼辦？ // fruit 是物件的可能寫法 function test(fruit) { if (fruit &amp;&amp; fruit.name) { // 若有值就印出水果名稱 console.log(fruit.name); } else { console.log(&quot;unknown&quot;); } } // 測試結果 test(undefined); // unknown test({}); // unknown test({ name: &quot;apple&quot;, color: &quot;red&quot; }); // apple 上面的範例中，我們希望水果名稱有值時就把它印出來，沒值就印出 unknown。其實，我們可以透過設定函式預設值與解構來減少 fruit &amp;&amp; fruit.name 這種條件判定。 // 透過解構賦予參數預設值 function test({ name } = {}) { console.log(name || &quot;unknown&quot;); } // 測試結果 test(undefined); // unknown test({}); // unknown test({ name: &quot;apple&quot;, color: &quot;red&quot; }); // apple 因為函式只需要用到物件 fruit 的屬性 name，所以我們可透過 {name} 將其解構出來使用，函式當中就可以拿 name 當作變數來參照，取代 fruit.name 寫法。 我們解構賦值時，至少要設定空物件 {} 為預設值。否則會出現這個錯誤：Uncaught TypeError: Cannot destructure propertynameof 'undefined' or 'null'.。 如果你不介意使用第三方函式庫的話，那麼我這裡有兩個方法可減少 null 的檢查： 使用 Lodash - get function 使用 Facebook 開源的 idx 函式庫 （需要 Bebeljs 轉譯） Lodash get function： _.get(object, path, [defaultValue]); Lodash 使用方法： function test(fruit) { // 若有值就印出水果名稱，否則採用預設值 'unknown' console.log(_.get(fruit, &quot;name&quot;, &quot;unknown&quot;)); } // 測試結果 test(undefined); // unknown test({}); // unknown test({ name: &quot;apple&quot;, color: &quot;red&quot; }); // apple 你可以在 Codepen 玩玩這段程式碼。如果你是 Functional Programming 愛好者，你可以把 Library 選項改成 Lodash fp（方法會改成 ._getOr），引數順序會從 a, b, c 改成 c, b, a。這裡有我的 FP v4.0 - demo。 Lodash FP 使用方法： function test(fruit) { // 若有值就印出水果名稱，否則採用預設值 'unknown' console.log(_.getOr(&quot;unknown&quot;, &quot;name&quot;, fruit)); } // 測試結果 test(undefined); // unknown test({}); // unknown test({ name: &quot;apple&quot;, color: &quot;red&quot; }); // apple 4. 相較於 Switch，Map / Object 是個好選擇 下面範例想要根據水果顏色，印出水果： function test(color) { // 使用 switch case，根據水果顏色印出水果 switch (color) { case &quot;red&quot;: return [&quot;apple&quot;, &quot;strawberry&quot;]; case &quot;yellow&quot;: return [&quot;banana&quot;, &quot;pineapple&quot;]; case &quot;purple&quot;: return [&quot;grape&quot;, &quot;plum&quot;]; default: return []; } } // 測試結果 test(null); // [] test(&quot;yellow&quot;); // ['banana', 'pineapple'] 程式碼邏輯雖沒錯，卻非常冗贅。相同的結果，可以利用物件實體語法（object literal），以清楚的語句來達成。 const fruitColor = { red: [&quot;apple&quot;, &quot;strawberry&quot;], yellow: [&quot;banana&quot;, &quot;pineapple&quot;], purple: [&quot;grape&quot;, &quot;plum&quot;] }; function test(color) { return fruitColor[color] || []; } // 測試結果 test(null); // [] test(&quot;yellow&quot;); // ['banana', 'pineapple'] 另一個選擇是 Map 達成相同結果： const fruitColor = new Map() .set(&quot;red&quot;, [&quot;apple&quot;, &quot;strawberry&quot;]) .set(&quot;yellow&quot;, [&quot;banana&quot;, &quot;pineapple&quot;]) .set(&quot;purple&quot;, [&quot;grape&quot;, &quot;plum&quot;]); function test(color) { return fruitColor.get(color) || []; } // 測試結果 test(null); // [] test(&quot;yellow&quot;); // ['banana', 'pineapple'] Map 是 ES2015 起來有的物件型別，讓你可以去儲存成對的 key 及 value。 那麼，難道我們該捨棄使用 Switch 嗎？別讓自己受限，就我個人而言，我會盡可能地使用物件實體語法（object literal），但我不會把規則定死，老話一句，一切只要適用於情境即可。 Todd Motto 寫過一篇文章在討論 switch 和 物件實體語法（object literal），有興趣可以看一下。 TL; DR; 重構語法 重構資料結構後，可以透過 Array.filter 達成相同結果： const fruits = [ { name: &quot;apple&quot;, color: &quot;red&quot; }, { name: &quot;strawberry&quot;, color: &quot;red&quot; }, { name: &quot;banana&quot;, color: &quot;yellow&quot; }, { name: &quot;pineapple&quot;, color: &quot;yellow&quot; }, { name: &quot;grape&quot;, color: &quot;purple&quot; }, { name: &quot;plum&quot;, color: &quot;purple&quot; } ]; function test(color) { return fruits.filter(f =&gt; f.color === color); } 總是有超過一種方式可以達成相同結果，以上已經提到 4 種程式範例，寫程式真的很有趣吧，呵呵。 5. 用 Array.every 和 Array.some 應用於全部與局部條件 最後一個技巧是利用 JavaScript 提供 Array 的新方法（但也不是那麼新啦）來減少程式碼的行數。來看看以下的程式碼，我們來檢查全部的水果是不是紅色的？ 檢查全部水果是否都是紅色的？ // 原本可能這樣寫 const fruits = [ { name: &quot;apple&quot;, color: &quot;red&quot; }, { name: &quot;banana&quot;, color: &quot;yellow&quot; }, { name: &quot;grape&quot;, color: &quot;purple&quot; } ]; function test() { let isAllRed = true; // 條件：全部的水果必須是紅色的 for (let f of fruits) { if (!isAllRed) break; isAllRed = f.color === &quot;red&quot;; } console.log(isAllRed); // false } 這樣的程式碼太長了，可以使用 Array.every 來減少程式碼： // 檢查全部水果是否符合條件 const fruits = [ { name: &quot;apple&quot;, color: &quot;red&quot; }, { name: &quot;banana&quot;, color: &quot;yellow&quot; }, { name: &quot;grape&quot;, color: &quot;purple&quot; } ]; function test() { // 條件：全部的水果必須是紅色的 const isAllRed = fruits.every(f =&gt; f.color === &quot;red&quot;); console.log(isAllRed); // false } 更清楚了吧？另一個相似的做法，如果我們想要檢查任一種水果是不是紅色的，可以用 Array.some 一行解決！ 檢查任一種水果是紅色的？ // 檢查任一種水果是否符合條件 const fruits = [ { name: &quot;apple&quot;, color: &quot;red&quot; }, { name: &quot;banana&quot;, color: &quot;yellow&quot; }, { name: &quot;grape&quot;, color: &quot;purple&quot; } ]; function test() { // 條件：只要其中有一種水果是紅色的 const isAnyRed = fruits.some(f =&gt; f.color === &quot;red&quot;); console.log(isAnyRed); // true } 結論 我們一起寫出更多易讀的程式吧，希望你看完這篇文章能有所獲。 那就這樣囉，Happy Coding! 覺得文章還不賴的話，訂閱我的 Twitter Reference 原文：5 Tips to Write Better Conditionals in JavaScript 參考：[五个小技巧让你写出更好的 JavaScript 条件语句](","link":"/javascript-good-condition-statement/"},{"title":"以 Vue 為例，如何在 VSCODE 自訂程式碼片段 Code Snippets？","text":"好，我習慣用的編輯器是 VSCODE，雖然有安裝一些 Snippets 擴充套件，讓我敲程式碼時比較不會因為打錯浪費時間 debug。但，真正開發時，創建結構時常常都要建立新檔案去切分 component，打幾乎同樣的程式碼有點煩，所以～找了一下該怎麼來設定自己要的程式碼片段。希望有幫助到你：） 一、設定 Setting.json 1-1. command + , 1-2. 右上角 {}，打開自定檔 1-3. 新增以下語法： // 啟用自訂程式碼樣版 &quot;editor.tabCompletion&quot;: &quot;on&quot;, // 如果你跟我一樣，有裝其他的 Snippet，可以將編輯器的權重提高 &quot;editor.snippetSuggestions&quot;: &quot;top&quot;, 二、在 VSCODE 新增自己的片段 2-1. shift + command + p 2-2. 輸入 &quot;User Snippets&quot;，選擇 Preferences:Configure User Snippets 2-3. 選擇語言，可以是 Global，因以 Vue 為例，我選擇 Vue。 有些參數說明，接下來，可以自己去瞭解參數或是使用 Snippets 設定產生工具！ VSCODE 官方說明 三、利用 snippet generator 創造自己的設定檔，感謝大大，快去追蹤他 XD snippet generator 產生器支援 VSCODE、SUBLIME、ATOM 唷，選擇自己的編輯器來設定吧。 prefix 就是你到時要生成自訂程式碼要輸入的。 { // 第一次建立的朋友 // 記得產生器產生的設定檔需要放在一個『物件』裡 // 之後可以往下繼續新增你其他的 Snippets // 將自訂的程式碼設定檔貼在這裡 } 像這樣： { &quot;Askie 自訂的 Vue 樣板&quot;: { &quot;prefix&quot;: &quot;vuetem&quot;, &quot;body&quot;: [ &quot;&lt;template&gt;&quot;, &quot; &lt;section&gt;Hello&lt;/section&gt;&quot;, &quot;&lt;/template&gt;&quot;, &quot;&quot;, &quot;&lt;script&gt;&quot;, &quot;export default {&quot;, &quot; name: 'Hello',&quot;, &quot; data() {&quot;, &quot; return {};&quot;, &quot; },&quot;, &quot; computed: {},&quot;, &quot; created() {},&quot;, &quot; mounted() {},&quot;, &quot; methods: {},&quot;, &quot; components: {},&quot;, &quot;};&quot;, &quot;&lt;/script&gt;&quot;, &quot;&quot;, &quot;&lt;style lang=\\&quot;scss\\&quot; scoped&gt;&quot;, &quot;&lt;/style&gt;&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Askie 自訂的 Vue 樣板&quot; } } Easy？ 不過我有踩一下雷，就是第一步驟的設定檔，以及最後要將設定內容全放在一個物件中，怕忘了，也感覺新手第一次建立時會遇到問題，所以簡單做個紀錄。","link":"/vscode-custom-user-code-snippets-steps/"},{"title":"輕鬆地提交 Hexo 部落格的 Sitemap.xml 到 Google Search Console","text":"查看使用者搜尋什麼關鍵字 想提升 SEO ，所以之前就有把我的部落格網址提交到 Google Search Console，在後台能了解： 成效報表：網頁搜尋總點擊次數 使用者點擊錯誤的網址數量 使用者會搜尋什麼關鍵字而到你的部落格 使用者是從哪些國家搜尋 行動裝置可用性…等等 其中，蠻喜歡這幾個功能 「索引 &gt; 涵蓋範圍 &gt; 排除』：能去看哪些是被檢索後但失效的。 「連結」：查看外部連結，哪些最熱門，來你的部落格的人又是點擊了哪些外部連結。 產生 Sitemap.xml 在 Hexo 這樣的靜態網頁產生器，沒想到提交 Sitemap 這麼地容易，簡單做個紀錄。有一個 Plugin 叫做 hexo-generator-sitemap，可以幫助你產生 Sitemap.xml，就可以拿這份檔案去提交了唷！來看以下簡單三個步驟。 安裝 Install Terminal 在部落格路徑下，輸入以下指令 npm install hexo-generator-sitemap --save 設定 Config 打開你的部落格資料夾，打開根目錄的 _config.yml，在最後面貼上： # 注意：yml 非常在意縮排。 sitemap: path: sitemap.xml template: ./sitemap_template.xml # 這行非必填，除非你想設定自訂的樣板 重新編譯一次，發布新內容： hexo g -d 檢查看看有沒有順利產生 Sitemap.xml？ https://askie.today/sitemap.xml =&gt; 我的 提交至 Google Search Console 打開 Google Search Console 進入「索引 &gt; Sitemap」 「新增 Sitemap」：sitemap.xml 如果成功，就可以在頁面下方的列表看見紀錄與狀態了。 結論 Hexo 利用工具就能簡單產出「網站地圖」，真方便！！","link":"/upload-sitemap-google-search-console-seo-hexo-blog/"},{"title":"簡單 ssh 進 instance，用 ssh_config 來幫你設定 alias","text":"ssh 進機器 常需要 ssh 進機器裡，會使用下列格式的語法： ssh -i ~/.ssh/[your-keyfile] [username]@[private_ip] 如果服務越來越多，我們需要 ssh 進去的機器也變多了，當然我們不可能每次都去找到 IP 再來複製貼上，這樣不僅工作速度慢， content switch 太頻繁會讓人心情不太好。因為超新手的關係，神同事可憐可憐我，貼了凍仁大大的文章讓我學習設定，很容易就能使用 😆，趕緊做筆記下來，一起加速！ ssh_config 如何設定 欄位介紹 Host：ssh 要連的代號名稱。 Hostname：IP 或 Domain Name。 Port：要連進去的 Port 號，ssh 沒改的話，預設 Port 號是 22。 User：使用者名稱。 identityfile：ssh key（絕對位置）。 # ----------------------------------------- # # [STG] Service A Host service-a Hostname 10.10.0.1 Port 22 User askie_lin identityfile ~/.ssh/opsworks # ----------------------------------------- # 如何透過 ~/.ssh/config 連上主機 ssh service-a 哇，真的超簡單，之後又超方便使用的 alias 設定，分享給大家，拯救被浪費的時間。 Reference [完全用 GNU/Linux 工作] 20. 增進 SSH 使用效率 - ssh_config","link":"/lets-set-ssh-config/"},{"title":"無障礙網站又稱為可訪問的網站，難道還有不可訪問的網站嗎？ What is an accessibe website exactly？","text":"只要花 60 秒瞭解「無障礙網站」概念 Your Website + Accessibility = BFF —— Jenn Lukas 前言 「網站」是一種資訊傳播的方式，我們製作網站最普遍的目的是為了將「資訊」傳播出去。比如說現今大多數公司會建置自己的官方網站，去傳達公司理念、服務項目、聯絡方式…等等，這些都在資訊的涵蓋範圍。 那你有聽過無障礙網站嗎？ 無障礙網站又稱為可訪問的網站，難道還有不可訪問的網站嗎？ 無障礙網站 無障礙網站又稱為 Web Accessibility 常以關鍵字 a11y 來代表無障礙技術，它是 Accessibility 的縮寫，代表網頁可訪問性，許多其他繁中翻譯會譯為可親性、可及性。這系列文章將以「可訪問性」代表 Accessibility、「無障礙」作為 Web Accessibility 的代稱。 縮寫方式 = A(ccessibilit)y = 以 A 為開頭，以 Y 結尾， A 與 Y 之間總共有 11 個字元！ 發音 可以唸作 A-one-one-Y 或是 A-eleven-Y，在業界也有人會唸作 ally 或是 alley 的發音。 其餘還有很多同樣形式的縮寫：如 g11n（globalization）、i18n（Internationalization）L10n（Localization）、p13n（personalization）、k8s（Kubernetes）等。 用愛開發，實踐「無障礙」 無論使用者是否有任何機能的低下、無論使用者使用何種方式與何種裝置瀏覽，無障礙的實踐將確保網站的內容以較多元、彈性的方式呈現，能夠提供給「所有人」瀏覽，有助於資訊能更廣泛地傳遞到更多人手中，拓展對不同能力的人的適應性。 重要性，你怎麼看？ 不可訪問的網站其實真的很多。 訪問性通常不是我們在設計、建置網站時的第一件事情，在某些問題出現以前，我們通常不會考量到隱形的需求。舉例一個情境：當我們處於產品開發週期的測試階段，某位使用者無法閱讀螢幕的文字，去瞭解才發現世界上男性中有 8% 的色盲。（從 WHO 了解視力障礙數據） 有些國家法律規定政府、教育機構、企業網站要符合無障礙的規範，以保障人權，訪問性的問題會在產品生命週期中蔓延，也會引發訴訟的問題。而且無障礙問題通常會出現在產品進入後期或是完成後，這時要從零導入「無障礙」實踐恐怕需要負擔更高額的成本。 再繼續往下之前，讓我們先來想想「障礙」的定義到底是什麼。 來思考「障礙」的定義 一個人有多種不同機能障礙的可能，「障礙（Disabled）」是一種相對的且會變動的狀態，也是一個事實的描述，是你的能力在所處「環境」下是否有辦法互動發揮作用而定。 在中文翻譯上，「無障礙」這個詞彙挺容易讓人直接聯想成：「喔！我們要做無障礙網站，那就是為了身心障礙人士瀏覽專用而設計嗎？」 無障礙網頁設計所設定的受惠者是「所有人」，與通用設計的理念相符，剛好其中有些特別的使用族群需要使用科技輔助工具（AT，全名為 Assistive Technology 如 NVDA、JAWS）、輔助功能（如 iOS 的 VoiceOver、Android 的 TalkBack）來瀏覽網頁，能力一般的人有時也有想要縮放網頁內容的需求，因此網頁在設計及開發時，設計上再細心一點，實作上注意細節就能增加網站的無障礙。讓我們用同理心、包容心和愛，盡可能達到「讓所有人瀏覽網站時都能享有獲得相同的資訊的權利」這個目標。 以人類的機能來區分障礙類型 物理，肢體上的障礙 開發基本原則：大多數的肢體障礙者都可以透過鍵盤瀏覽網站，所以開發時專注鍵盤的可訪問性。 創傷： 肢體損壞 脊髓損傷 疾病與先天性疾病： 腦癱 關節炎 帕金森氏症 認知，學習和神經系統的障礙 記憶力不佳 解決問題的能力 注意力不集中：自閉症、過動症（ADHD） 閱讀與言語理解困難 癲癇 動暈症（如暈車、暈船） 聽覺 開發基本原則：影片提供字幕或是手語翻譯、專注於螢幕閱讀器的可訪問性。 輕度：無法聽到 30 分貝以下的聲音。 中度：無法聽到 50 分貝以下的聲音。 重度：無法聽到 80 分貝以下的聲音。主要透過手語溝通。 嚴重：無法聽到 95 分貝以下的聲音。主要透過手語溝通。 視覺 開發基本原則：提升顏色對比度、填寫替代文字、減少顏文字的使用、確保超連結文字的提示性、超連結的路徑不要寫無意義的 JavaScript（ href=&quot;javascript: void;&quot; ）、勿僅靠顏色作為傳達重要訊息的唯一方式、資訊結構順序設計、文字不要壓在圖上…等。 色盲 色弱 失明 近視 青光眼 白化症 年邁的老人 還有一些是屬於暫時性或環境的障礙，比如網路速度不佳的問題、我們因為車禍導致手臂受傷而暫時無法使用滑鼠。 現實生活有哪些透過輔助技術消彌障礙的情境？ 近視配戴眼鏡或隱形眼鏡 長者配戴老花眼鏡 地面止滑設計防止行人跌倒 編輯器使用程式碼自動完成工具 … 多到不勝枚舉，因為習慣有輔助科技及輔助技術的協助，讓我們忽略自己的生活情境，也常需要透過外力協助去解決我們的問題。 體驗一下！讓開發者也有「色盲」 這邊舉一個小例子，讓各位感受一下色盲在觀看網頁時的感覺： import React from 'react'; import MenuItem from '../shared/menu'; import ItemMenu from '../shared/menu'; const App = () =&gt; ( &lt;&gt; &lt;MenuItem title=&quot;Home&quot; /&gt; &lt;MenuItem title=&quot;About&quot; /&gt; &lt;ItemMenu title=&quot;FAQ&quot; /&gt; &lt;MenuItem title=&quot;Gallery&quot; /&gt; &lt;ItemMenu title=&quot;Signup&quot; /&gt; &lt;MenuItem title=&quot;Contact Us&quot; /&gt; &lt;/&gt; ); export default App; 色盲的人永遠也不知道正常的人眼中看到的世界，就像正常人也永遠無法看到色盲人眼中的世界。若把「色盲瀏覽網頁」以「開發者觀看程式碼」來比喻的話就長上面這個樣子，原來是這麼難以閱讀。 開發無障礙網頁的好處 很多企業都開始重視起無障礙網站，因為實踐無障礙網站的過程，還可以達成以下優點 提高 SEO 搜尋引擎排名（看看這篇的內容） 吸引更廣泛的受眾、拓展市場機會 展示社會責任 提高易用性（Usability） 編寫更清晰的程式碼 降低產品成本：避免日後產品迭代時才需要從零導入無障礙的窘境 協助網路速度慢的使用者訪問 看完文章後，對於無障礙網站的觀念是不是有更多的認識跟釐清了呢？ 就跟著接下來的篇幅一起實踐可訪問的網站吧！ Reference Cognitve - WebAIM Visual - WebAIM Auditory - WebAIM Assistive - WebAIM Seizure - WebAIM React Rally 2019 @YouTube What is Web Accessibility in 60 seconds! - Google Women Techmaker Blindness and vision impairment - WTO 設計師 YR Cheng 聊聊 Accessibility Wikipedia - Accessibility Myth: Accessibility is ‘blind people’ - The A11Y Project","link":"/what-is-an-accessibe-website-exactly/"},{"title":"符合無障礙規範一定要了解！把「通用設計」的思考融入骨子裡","text":"現在因為要製作政府的專案，需要符合國家通訊傳播委員會的無障礙規範，google 通用設計的概念，意圖去了解無障礙設計與通用設計的差異。後來看到大愛電視台，唐峰正老師的分享「通用設計」，發現：其實我們做的每一件事情都能增添溫度 - 同理心。 大家都知道，一個好的網站需要包含很多要素。其中有一個很大的 topic，「Accessible Web / Accessibility」，卻經常淪為建構網站時，有時間才去優化的事情，是一個 option 而不是 main feature。 Accessibility \\-​ˌse-​sə-​ˈbi-​lə-​tē \\ 中文常翻譯為「網頁親和力」。線上字典聽發音。 學習到的重點 無障礙設計 專爲身障者考量的設計，讓他們使用設備或空間時不會受到阻礙。 通用設計是「利他精神」。 目的是：不凸顯使用者差異、不增加其心理負擔。通用設計所考量的對象則不侷限於身障者，還有其他的使用族群，也許是身體機能退化的高齡者，也可能是使用習慣和多數人不同的左撇子，或是身材嬌小的矮個子、大腹便便的孕婦、推著娃娃車的人等等。 無障礙設計與通用設計最大的區別（2019-07-28 補充） Universal design is different from accessible design in that there are not two different solutions - 來源 「無障礙設計 Accessible Design」需要考量不同對象而有需要額外製作第二套解決方案，而「通用設計 Universal Design」沒有兩種不同的方案，而是一種方式就能滿足所有人的需求。 如果一開始就針對全民設計，將會： 成本降低 使用者增加 七大原則 公平 簡單易用 彈性 空間 容錯 省力 直覺 人生大風車：人生有大多數充斥的需要被設計的事物。 人生不同階段 幼兒 學生 社會人士 老年 不同的椅子 娃娃車 學生椅 電腦椅 輪椅 「同理心」並非「同情心」，而是有溫度的思考。也就是以下： 只要有表達出來，我都願意幫你 在被幫助的時候，也不要因為被幫助，而喪失自己原本的能力 把彼此的問題，都加進來一起思考 全人關懷環境，去思考： 誰在用？ 誰要用？ 誰想用？ 專心做一件事，過程中也許會被質疑、不認同你，但當它出現意義、出現價值時，你才可以告訴你自己，你是活著的。＿唐峰正顧問 上面這句話，不小心融入我的血裡、我的骨子裡了。 稍稍了解之後，我的想法是，如果網站在建構初期時，設計者與開發者有著全面族群的思考方向，自然就容易把事情做好、把格局做大。 補充無障礙相關資訊！（方便別人、方便自己） 線上資源 如果你也跟我一樣：目前正在了解無障礙的規範該如何去實踐，不外乎要知道載體、開發者工具的使用、語意標籤及相關的 aria-label 內容設定。 可以參考的線上資源有：Google Web Fundamental 及 Google 提供的免費課程、w3org: WAI-ARIA Overview、w3org: Accessibility Fundamentals、web.dev: Accessible to all 有規範 / 建議 / 學習資源。 之後完成專案後再來說一下心得與工具。 我這個專案將會使用 Vue 開發，其實不論你用什麼框架，真正的關鍵字，叫做「A11Y」，是 eslint 的套件，當你的結構未符合 Accessibility 時就會有錯誤提示，感謝 Huli 胡立大大 的補充！^^ Vue 可以使用：eslint-plugin-vue-a11y，more… React 可以使用：eslint-plugin-jsx-a11y Checklist for 網站無障礙規範 2.0 版 A 級 如果你也跟我一樣：需要符合政府的規範，也就是國家通訊傳播委員會的無障礙檢測，總共有三個等級（A, AA, AAA），我目前只需要通過 A 級，但因為官方的規範，結構、配色實在太難閱讀… 為了不想瞎掉，所以我手動整理了一個共筆清單，方便大家複製一份自己用。符合規範就自己打勾，也方便做 spec 驗收時確認，總之有一個 TOC 及資訊層級整理，總是比官方的版本閱讀性提高太多，較容易查找（OS: 明明就是官方的無障礙規範，排版排得連一般人都難以閱讀是怎樣 = =）。 我整理的共筆連結在此，歡迎拿去使用，官方範例也正在整理中 Issues 國家通訊委員會有提供檢測工具 Freego，我的電腦是 MacBook Pro，下載 Linux 版本卻不能使用，命令列似乎說有缺少的 java 套件…。 Reference 通用設計與無障礙設計的差異 Universal Design for Public Services 公共服務如何導入通用設計（余虹儀） 通用設計大學問 - 唐峰正顧問（萬分感謝！您真偉大）","link":"/accessible-design-and-universal-design-principles-for-all/"},{"title":"從零開始設定自己的開發環境、軟體推薦（MacOS）","text":"最近到了新的工作環境，公司配了一台新電腦，要從零來設置自己習慣的開發環境，所以除了安裝開發上很順手的工具以外，也額外想推薦大家來安裝能夠增加效率或是提升開發速度的軟體。這篇文章不會各別介紹每個工具詳細設定的流程，我選擇紀錄每個推薦的工具能夠為我解決什麼問題，等於是為了以後買新電腦又要重設開發環境做準備（？） 1. HomeBrew HomeBrew 官網 安裝各式套件的管道。 安裝指令 $ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安裝後，確認版本 $ brew --version 2. GIT GIT 官網 版本控制管理系統，應該沒有開發者不知道，教學可以看高見龍老師的為你自己學 GIT。 剛開始使用 GIT 的初始化 檢視目前電腦中 GIT 全域設定的使用者是誰。可以看這一篇文章。 $ git config --list user.name=Eddie Kao user.email=eddie@5xruby.tw 都還沒設定過的話，來設定一下： $ git config --global user.name &quot;Askie Lin&quot; $ git config --global user.email &quot;askie_lin@xxxxxx.com&quot; 每個專案使用不同作者 在自己的專案中，透過 --local 參數來達成： $ git config --local user.name Kai $ git config --local user.email &quot;Kai@xxxxxx.com&quot; 做好修改的檔案會在這底下：~/.gitconfig 加上 log 高亮語法及 alias 增進你的速度，我的 ~/.gitconfig： [user] name = Askie Lin email = askie_lin@xxxxxx.com [alias] co = checkout br = branch cm = commit ca = commit --amend cane = commit --amend --no-edit st = status rb = rebase lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --branches 但其實如果說 alias 增進速度這一塊，我沒有使用很多 alias 的設定，只單純設定使用頻率頻繁的。 3. NVM NVM 官方文件 使用安裝 node，可以根據環境切換版本，也可以參考 node 官網對於 NVM 的使用說明：Installing Node.js via package manager 及這篇 Mac OSX 新手入門。 4. 安裝 iTerm 2 + Zsh iTerm 2 官網 讓 Terminal 可以自訂顯示的資訊及 UI，如顯示所在路徑、GIT 分支及狀態其實不只是好看，能夠增加工作效率。 關於 Zsh 一定要使用的設定 安裝 Auto suggestions (for Oh My Zsh) 能夠讓我們在 Terminal 輸入指令時，自動提示輸入過的指令，激推！ 簡述一下流程，流程取自於 PJCHENDer 的文章：為 MAC 的 Terminal 上色 - 透過 iTerm 2 和 Oh My Zsh 高亮你的終端機 在終端機輸入： $ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 打開 ZSH 設定檔： $ open ~/.zshrc 找到 plugins = “” 的地方，在 plugins 的欄位中加入”zsh-autosuggestion”後存檔： 原本 $ plugins=(git) 改成 $ plugins=(git zsh-autosuggestions) 5. 安裝 Visual Studio Code VS Code 官網 很棒的免費的編輯器，有中文化，擴充套件也很齊全。 推薦安裝 VS Code： SettingSync 有效備份每次的設定，在需要重新設定環境時，無痛接軌！ Terminal 使用 code 指令打開專案 想在 Terminal 想直接使用 VS Code 開啟專案嗎？ $ code . # 當前目錄路徑 $ code /anyDirectory/you/want # 資料夾路徑 如果遇見以下錯誤訊息該怎辦？ zsh: command not found: code 查看 StackOverflow - “code .” Not working in Command Line for Visual Studio Code on OSX/Mac 這篇說明唷！ 6. 建立 SSH Key 教學激推 讓你從 GitHub 或 GitLab 拉原始碼回來時可以透過 SSH Key 的方式，安全、方便、快速的 clone。使用 HTTPS 的方式則是每次都會詢問帳號、密碼，非常繁瑣。 7. Postman POSTMAN 官網 打 API 的好幫手。 8. Magnet（付費） Magnet 官網 App Store 下載 Window Manager，讓 MAC 使用者用快速鍵就能輕鬆分配應用程式該放在螢幕的哪個位置。Perfect！ 記錄完了，收工！","link":"/how-to-setup-develop-environment/"},{"title":"RegExp 踩雷：Lookbehind Assertions","text":"RegExp in JavaScript 之前對正規表達式一直不太熟悉，也沒仔細去研究正則規則寫法是什麼種類，所以踩到支援性的雷。大多數正規式會支援正規表達式的原因是，它是一個對於文字操作非常強大的工具，本來要寫數十行複雜邏輯的判斷式，只要一行就能達成。 ES2018 新增的功能 正則表達式在 1999 年在 ECMAScript 標準第三版成為 JavaScript 的一部份，而在 ES2018 標準第九版時，新增了以下的功能，大幅改善對文字處理的能力。這邊文章要說明的是關於 assertions，大部分程式碼範例參考自此篇文章。 Lookbehind assertions Named capture groups a(dot) Flag Unidocde property escapes 這些新功能的支援度目前還不高，尤其是 lookbehind 支援 Assertions 想要 match 文字是否符合規則，需要仰賴文字前後的順序，從而丟棄不合規則的 pattern。尤其是當我們處理到很長的字串，比對的過程中，幾乎都是不正確的格式。好險正則表達式基本上都有提供 lookbehind assertions 和 lookahead assertions，讓我們的格式判斷能有效率。 Lookhead 在 ES2018 之前，JavaScript 有提供lookahead assertion，分為 positive 和 negative。 Positive lookahead 用 (?=...) const re = /Project(?= 10)/; console.log(re.exec('Project')); // null console.log(re.exec('Project5')); // null console.log(re.exec('Project 5')); // null console.log(re.exec('Project 10')); // [&quot;Project&quot;, index: 0, input: &quot;Project 10&quot;, groups: undefined] Negative lookahead 用 (?!...) const re2 = /Lucky(?!Star)/; console.log(re2.exec('LuckyStar')); // null console.log(re2.exec('LuckyGuy')); // [&quot;Lucky&quot;, index: 0, input: &quot;LuckyGuy&quot;, groups: undefined] console.log(re2.exec('LuckyOne')); // [&quot;Lucky&quot;, index: 0, input: &quot;LuckyOne&quot;, groups: undefined] console.log(re2.exec('Lucky')); // [&quot;Lucky&quot;, index: 0, input: &quot;Lucky&quot;, groups: undefined] Lookbehind ES2018 ，JavaScript 新增了lookbehind assertions作為 lookahead assertions，一樣分為 positive 和 negative。 Positive lookbehind 用 (?&lt;=...) const re = /(?&lt;=€)\\d+(\\.\\d*)?/; console.log(re.exec('199')); // null console.log(re.exec('$199')); // null console.log(re.exec('€199')); // [&quot;199&quot;, undefined, index: 1, input: &quot;€199&quot;, groups: undefined] Negative lookbehind 用 (?&lt;!...) const re = /(?&lt;!\\d{3}) meters/; console.log(re.exec('10 meters')); // [&quot; meters&quot;, index: 2, input: &quot;10 meters&quot;, groups: undefined] console.log(re.exec('100 meters')); // null 搭配一同使用 positive lookbehind (?&lt;=...) 和 negative lookbehind (?&lt;!...) const re = /(?&lt;=\\d{2})(?&lt;!35) meters/; console.log(re.exec('35 meters')); // → null console.log(re.exec('meters')); // → null console.log(re.exec('4 meters')); // → null console.log(re.exec('14 meters')); // → [&quot;meters&quot;, index: 2, input: &quot;14 meters&quot;, groups: undefined] 數字要兩位數。 並且，數字不是 35。 符合以上兩個規則， exec() 就會回傳找到的結果陣列。 Reference New JavaScript Features That Will Change How You Write Regex - by Faraz Kelhini Lookbehind in JS regular expressions - Can I Use https://zhuanlan.zhihu.com/p/56981997","link":"/regexp-lookbehind-assertions/"},{"title":"忍者 2：Web 應用程式生命週期","text":"本文內容涵蓋 Web 應用程式生命週期 處理 HTML 以產生網頁 JS 程式碼的執行順序 與事件互動 事件迴圈 Web 應用程式生命週期 Web 應用程式真正的生命起始於第四步驟：收到伺服器回傳的頁面時。 使用者：輸入網址或是點擊超連結 瀏覽器：產生請求並送往伺服器 伺服器：收到請求，執行動作或是取得資源，將回應送回客戶端 瀏覽器：收到回應頁面，解析 HTML、CSS、JavaScript 並渲染頁面 [頁面建立階段] 瀏覽器與使用者：[事件處理] 瀏覽器監看事件佇列 使用者與頁面元素互動 瀏覽器一次處理一個事件 … 持續這個循環 使用者關閉 Web 應用程式 Ｗ eb 應用程式也是一種圖形使用者介面，所以和其他 GUI 應用程式一樣，都是先建立頁面，再進行事件處理直至被使用者關閉，就結束了生命週期。 頁面建立階段 設置使用者頁面。 事件處理階段 進入一個等待事件發生的迴圈，並啟用事件處理器。 生命週期結束 使用者關閉 Web 應用程式。 頁面建立階段 _ (4) 網頁在可以被操作或單純顯示之前，瀏覽器須先根據伺服器接收到的回應內容（HTML、CSS、JavaScript），此階段的目標是「設置 UI」，分為兩個步驟： 解析 HTML 並建立文件物件模型 DOM 執行 JavaScript 程式 瀏覽器處理 HTML 節點時執行「步驟 1」，每次只處理一個節點； 當遇到特殊類型 HTML 元素，即是包含/引用 JavaScript 的 &lt;script&gt;，就執行「步驟 2」。 HTML 節點關係 父節點、子節點、兄弟節點。 瀏覽器能否永遠正確地根據 HTML 產生網頁 DOM 文件物件模型，其實 DOM 不等於 HTML，雖然 DOM 是由 HTML 建構，但 HTML 其實是 DOM 建構時所遵循的藍圖，若建構時發現錯誤，瀏覽器會容錯、修復它，如此才能夠建構「有效」的 DOM。 &lt;head&gt; 的設計意圖 用於提供一般性的頁面訊息，比如說：網頁標題、字元編碼、外部樣式、外部程式。 不是用來定義「頁面內容」（DOM）的，所以如果把非頁面訊息的元素，放進 &lt;head&gt;，會被瀏覽器靜靜地修復，比如說 &lt;p&gt;，就會被默默移動到 &lt;body&gt; 中。 頁面建立階段時，遇到特殊類型 HTML 元素 &lt;script&gt; &lt;script&gt; 元素用來包含 JavaScript 程式碼。 而在這個情況之下，瀏覽器會暫停建立 DOM 結構，而先執行 JavaScript 程式碼。 瀏覽器的 JavaScript 引擎 &lt;script&gt; 中的程式碼，由瀏覽器的 JavaScript 引擎執行，提供頁面動態行為。 Firefox：Spidermonkey Chrome：V8 Opera：V8 Edge(IE)：Chakra JavaScript 全域物件 瀏覽器中 JavaScript 引擎的全域物件是 window 物件，代表頁面所屬的「瀏覽器視窗」。 window 物件是特殊的全域物件，因為它可以存取： 所有其他的全域物件 全域變數（包含使用者自訂的全域變數） 瀏覽器 API window 物件中，最重要的屬性是 document，代表目前頁面的 DOM 結構，透過 document 物件，JavaScript 可以任意建立及插入、修改、刪除等所在頁面的 DOM 結構，但也有一些無法做到的事，比如選取和刪除尚未建立的元素。因為有時 JavaScript 程式碼還沒被讀取，故有些元素還沒透過 JavaScript 建立並插入到 DOM 中，所以有些開發者傾向將 &lt;script&gt; 放在頁面底部。 事件處理階段 _ (5) 頁面互動性 在頁面建立階段，除了修改 DOM 以外，還能註冊事件監聽器（Event Handler），監聽使用者的操作，當某些操作被觸發時，瀏覽器會針對不同類型的事件做出反應，也就是呼叫被定義好要觸發的函式（Callback）。透過這樣的流程，去增加頁面的互動性。 事件處理概述 瀏覽器執行環境的核心是「單一執行緒」，也就是一次只執行一段程式碼。 瀏覽器透過「事件佇列」追蹤已發生但尚未處理的事件，並且這些事件都會按照發生的順序放在同一個事件佇列中。 流程： +---------+ 檢測 +------------------+ 是 +-----------+ | 瀏覽器 | =&gt; | 事件佇列頂部有事件？| =&gt; | 執行一個事件 | +---------+ +------------------+ +-----------+ ↑ 繼續檢測 ↓ 否 +-------------+ 將事件放入事件佇列中這件事情，是瀏覽器的工作機制，並不在頁面建立和事件處理階段之中，所以判斷何時該執行、加入佇列的這個動作不在事件處理的執行緒中。 事件是「非同步」的。 絕大多數程式碼會被這些事件類型觸發： 瀏覽器事件：網頁處於已經載入或未載入的狀態 網路事件：Ajax 事件、Server 端事件 使用者事件：使用者點擊滑鼠 計時器事件 註冊事件處理器（Event-handler Registration） 兩種方式可以註冊 將函式只給特定屬性：一次只能指派一個事件處理器，下次註冊就會清空前次的內容。 window.onload = function () {}; document.body.onclick = function () {}; 使用內建的 addEventlistener：針對同個元素，可以新增多個相同或不同的事件處理器。 window.addEventListener('load', function () {}); document.body.addEventListener('click', function () {}); 簡易 QA 一個 Web 應用程式可以同時處理多少個事件？ 一個。 為什麼瀏覽器必須使用事件佇列來處理多個事件？ 因為需要追蹤已經發生但尚未處理的事件。","link":"/javascript-ninja-2-web-lifecyle/"},{"title":"系統設計入門：效能與可擴展性的差異","text":"本系列文並非自己實務心得記錄，而是讀 System Design Primer 的筆記，有蠻大部分節錄自該文章以及其補充連結。 工程師常拿 Scalability 來討論，最後也常以「但是它不能擴」作為雙方的結論。這表示系統確實經常被限縮。 怎樣的服務算是擁有「可擴展性 Scalability」 比如說，為了提高所提供服務的可靠性，需要納入冗餘（Redundancy）的設計理念，降低系統執行對單一伺服器的依賴程度，卻不會因而犧牲效能。 當資源投入時，服務的效能還能增加，也就是「效能增長程度」與「資源投入」成正比時，那麼這個服務即擁有可擴展性。因為效能增加代表服務可以處理更多資料，也就能服務更多的工作單位，我們就擁有擴展資源的可能性，而不會為了會損失效能而選擇折衷，導致服務失去更多可能性。 對於單一個使用者來說 系統存在「效能」問題時，他會覺得「慢」。 系統存在「可擴展性」問題時，他會覺得較快，但系統「高負載」時，就會覺得「變慢」。 比如某些演算法，使用者平常感覺都很良好，只有在系統進入高負載時會影響甚巨。 最難的地方 無法事後設計 因為可擴展性這件事情，必須要在事前先思考、設計、再開始開發，開發後才開始想到這一層面，往往無法因應。 異質性 Heterogeneity 需要考量不同版本的硬體設備都有其異質性，且更強大的工具通常需要付出更昂貴的成本。 Check List 確保系統沿著期望的方向成長 哪裡需要冗餘 應該如何處理系統中的異質性 Solution Architect 需知道在哪些條件下他們可以使用哪些工具以及其常見缺點 Weekly Notes Multi-tier architecture：3-tier Architecture 是最常使用的架構，尤其是電商網站。 Presentation Layer a.k.a. UI layer（Presentation tier） PC, Tablet, Mobile, etc. Application Layer（Logic tier） Web Server Database Server（Data tier） Performance → Scale-up 新增機器，若依舊無法改善就是 Scalability Problem Scalability → Scale-out Web Server Load Balancer / L4 switch 一定要有 health check 一定要有 Policy 流量分配方式： Round-robin 依序循環、 Least connection、 先經過演算法 hash 過，指向 FQDN，印象中是 ELB 預設方式。 DB Server Data Replication，加一層 HA proxy、ProxySQL、Route server (Asynced) - Multi-source 有 Delay 的考量 Binlog 去備份，會自動比較差異 Read：很棒 Write：容易因為 delay 衝突 Scale-out：要寫 script 自動化去 sync (Synced) - PXC - Data Read 量大可以選用的 solution，不然 node 多容易有效能慢的問題 Read：很棒 Write：等所有 DB server 都完成才算真正完成 ⇒ 寫入 Scale-out：自動化同步，但如果 size 大要找一個東西花很久時間 Data Partitioning and Sharding，加一層 Route Server 水平分割：table 只存某種 type，比如身分證字號 A 開頭的存一個表 垂直分割：table 只存某欄位，比如性別欄位存一個表 MongoDB Sharding：透過 Route server 去問 ConfigDB 取得 sharding key，得知要存在哪個表 Write：透過 ConfigDB 知道要寫到哪 Read：透過 ConfigDB 知道要存到哪 Scale-out：加新 node 很輕鬆，只要設定好 ConfigDB，自動化 re-balance data，做更合適的分散。 Jack 分享電商 XXhome 的經驗： 現在的系統做大後要拆分的最根本原因是因為 User 需求量大增。 所以背後有 Cluster 群在服務這些請求。 再把來源拆一拆就能分流： 圖片有專屬的機器 API 也拆一拆 所以雲端服務： 只要背後做得穩、快。 剩下的就是做好使用者經驗，也就是 Front-end + UI/UX ⇒ 我自己的結論。 Reference System Design Primer A Word on Scalability - Werner Vogels Scalability, Availability &amp; Stability Patterns","link":"/system-design-primer-performance-vs-scalability/"},{"title":"My love","text":"2014 年 1 月 25 日 週六 第一次遇見她的日子 她才一個月大 誤打誤撞地推翻原本的計畫 唸書的我能照顧她的餘生嗎？ 抱著無論如何都不讓她再受風吹雨淋的決心 直到了現在都沒有停 貓咪的個性跟人很像 因為，每隻貓咪個性都截然不同 喜歡黏我撒嬌加上強烈的佔有慾 傲嬌的她，總是使出渾身解數的表演吸眼球 她愛我就如同我愛她的深度 陪伴跟傾聽是她會的 她甚至，還會保護我 在我最脆弱的時候","link":"/nami-introduction/"},{"title":"Docker 初探：基本指令與簡單介紹 Dockerfile 和 docker-compose","text":"TL;DR 本文不會有太多語法說明，打算介紹： Docker 的前世今生 Container 名稱由來 如何運行基本的 Docker 指令 簡單介紹 Dockerfile 和 docker-compose 的用途（新手常搞不清楚） 一切內容僅是讀書紀錄，讀的書請參考本文最下方的 Reference，如果有錯誤請大家指正觀念。 讀 Docker 背景之前覺得會不會因為文鄒鄒讀不下去，讀完之後才發現只有這樣才能更了解歷史脈絡，以及這個技術背後的基礎是基於什麼，也是挺有趣的。 Docker 的前世今生 Containers are based on virtualization technology. 虛擬化技術 電腦出現之後，開發者思考的是如何將程式無縫移植到其他機器還能正常執行，由於不同廠商生產的 CPU 其指令集往往差異很大、機器會連接不同硬體、運行不同作業系統等原因，所以環境一致性是最困擾的問題。在這方面，IBM 是做最早提出虛擬化的公司（60 年代），讓程式執行於虛擬環境時，看不見被隱藏的真實環境，取而代之的是被事先設定好的硬體環境，從而彌平環境問題。 硬體虛擬化 當時的解決方案僅限解決 IBM 大型硬體機器，成本過高，於當時也不易推廣。從前的大型網站通常採用大型實體機器，網路發展快速，漸而轉向小型機器發展，隨著雲端計算時代來臨，計算的量變得巨大，升級機器的成本指數成長，好可怕！ 分散式系統 現在大型服務可以透過將應用程式分散到各地不同的小型機器上，再組成叢集一起計算、協作，完成該服務需提供的工作，就可稱作分散式系統。當很多大公司開始採用叢集方式建構服務，比如臉書，程式部署在不同機器上的環境問題又浮上檯面。（叢集定義可查看 wiki、鳥哥更多介紹） 而「虛擬化技術」是電腦資源的管理技術，CPU、Storage、Network，將資源抽象化為統一介面給程式。 軟體虛擬化 虛擬機器（Virtual Machine）就是軟體實作，通常會在應用程式和硬體資源將建立一個 Hypervisor 層，它是統一的呼叫介面，將呼叫轉換為實體主機對應的資源呼叫方式。 容器化技術 虛擬機器，簡稱 VM，在跨平台部署有很好的表現，只是低落效率阻礙它的發展，而後衍伸了容器化技術的概念：將應用程式打包到單獨的容器中、封裝，容器可以隔離每個程式並打斷程式的依賴關係。 好處： 就像堆積木（Component）一樣，結構鬆散，降低程式之間藕合性 擁有統一的介面，很容易重新組裝和抽換服務的功能 提一下 Linux Containers（LXC）它是作業系統層級的虛擬化技術/容器，它運用實體機器資源再模擬虛擬環境，所以移除 Hypervisor 層，不用再轉換指令，大幅提高效率囉！ 主要有兩項核心功能組成： Namespace 命名空間 隔離的用途 很容易將不同程式隔離在不同環境，也就是說不同命名空間的程式是互不可見 CGroups （Control Group）控制群組 資源管控 如同大腦般的控制該容器可用的電腦資源：CPU、Memory、IO Docker 2013 年，dotCloud 公司將內部開發的 Docker 開源，基於上面提到的 LXC 技術基礎，將系統設計容器轉為微服務（Micro-service）的容器！因為很火熱，dotCloud 後來索性改名叫做 Docker Inc 現在成熟的 Docker 已經不是以 LXC 為架構，而是自己開發的 Libcontainer 作為底層的技術。 我們不用再管虛擬化怎麼實現的，只要管容器該怎麼操作！ （翻譯蒟蒻：只要管積木該怎麼拼 ⇒ 只要管程式元件該怎麼組成）。 Docker 啟動與執行 啟動：啟動 Docker 時，其實啟動的是背後的 Server - Docker Daemon 執行：控制 Docker CLI，透過 Docker REST API 發送指令給 Docker Daemon Docker 四大核心模組 Image 映像 ⇒ 容器要打包的程式 Container 容器 ⇒ 隔離好的環境 Data Volumes Network Container 容器一詞的由來 早期的運輸皆是靠海運，因為貨物規格、形狀、材質都不一樣，工人為了最大化運用船的空間，需要花費大量時間裝卸。碼頭數量有限，如果每一艘船都很慢，效率很不佳，直到貨櫃的發明，貨櫃被設計成規格大小皆一致，大大提升運輸效率，促進全球化。 Container 的中文翻譯就是貨櫃的意思。 貨櫃：把「貨物」隔離到不同「箱子」中，消除「不同貨物規格」的影響。 容器：把「程式」隔離到不同「容器」中，消除「不同執行環境」的影響。 Docker Image 顯示：askie/helloworld:lastest 格式：Namespace/Repository:Tag 由此格式會用 Sha256 方式加密成為 Image ID （64 位元 16 進位字串） Namespace：用來辨別組織或個人，可以寫自己名字 Repository：檔案名稱，寫應用程式名稱 Tag：參考 Git 的 Tag，也是用來記錄程式的版本 Docker 基本使用流程 超級類似 GIT 的概念吧！ DockerHub（Public） 類似 GitHub，是可以上傳跟下載的 Docker 公開庫。 Docker Registry（Private） 有些企業會考量隱私性及安全性，在內部網路架設一台 Docker Registry Server（Private）。 Local 端安裝好 Docker 之後… 安裝流程請參考官網，這裡不贅述。 1. 拉一個 Image 回來 檢視現有 Image 有哪些： docker image ls 假設拉一個普羅米修斯回來： docker pull prom/promtheus 還記得 image 格式 Namespace/Repository:Tag？不加 tag 時，預設會拉最新版本回來！ 2. Container 跑起來 Run 起一個 Container：用 prom/promtheus 這個 image 背景執行一個容器環境，取名叫做 prom-server。 docker run -d -p 9090:9090 --name prom-server prom/promtheus 參數說明： -d 背景執行 -p port 號設定，本機 9090 port 來對應虛擬環境的 9090 port —-name 容器名稱 3. 進入 Container 執行環境 docker exec -it prom-server /bin/sh ... ... 做你要做的事情 進入執行環境中的 /bin/sh 資料夾下，類似於 SSH 進入機器的概念 4. 版控更新過的 Container 環境 docker commit -m &quot;test&quot; &lt;your_image_id&gt; askie/prometheus:v2 -m 輸入版本控制的訊息狀態 your_image_id 透過 docker image ls 取得要紀錄的 ID 5. 將新 Image 推到 Docker Registry docker login docker push askie/prometheus:v2 要 login 需註冊並且有權限 Dockerfile Dockerfile 是一個設定檔，專門管理單一 Container，讓我們可以透過指令的設定，快速地更新 Container 的環境。 Dockerfile 檔案內容，注意，首字大寫 透過 Docker CLI 來快速更新容器環境 docker build -t vrops_prometheus docker-compose 現在很多服務背後都是採用分散式系統的架構，所以一個微服務用一個容器裝起來，眾多的微服務，就需要使用可以管理多個 Container 的工具 docker-compose。（題外話：有了 K8S，基本上工作上都是採用 K8S 來管理多個容器，功能強大！） 它的基本指令很簡單，其原理是撰寫 docker-compose.yml 來設定你的 services 該指向哪些 image、Port 對應、該走哪些任務。 docker-compose start docker-compose stop docker-compose pause docker-compose unpause docker-compose ps docker-compose up docker-compose down CheatSheet 有了以上這些基礎觀念之後，接下來只要熟悉語法即可。 Docker CLI CheatSheet Dockerfile CheatSheet docker-compose CheatSheet 好了，初探就介紹到這裡了，歡迎指正，也希望對新手有點幫助，觀念通了工具用起來才有感覺。 Reference Docker 專業養成 活用基礎與實踐技能 — 熊昌隆 我同事","link":"/docker-dockerfile-dockercompose-intro/"},{"title":"初心者透過官方文件學習 React 十大概念（上）","text":"記錄著關於初學 REACT 時，官方文件提及的主要概念，基本上都是文件上的內容，希望用自己是初心者的方式整理關於 JSX、生命週期、事件處理器、官方文件的觀念，可以更記得住。 1. Hello World 應用程式基本組成：元素與組件。 ReactDOM.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); 往下瞭解其他概念之前，可以先閱讀「重新介紹 JavaScipt」，如果好幾年沒碰 JavaScript 的話，看一下「三個心法」。 重新介紹 JavaScript：複習 JS 的主要核心概念，推薦閱讀！ 三個心法 以 let與 const定義變數，暫時當作與 var一樣意思的關鍵字。 使用 class關鍵字來定義 JavaScript class，有兩件事要知道： class中的方法定義不像 object一樣需要使用逗號做為區隔。 JavaScript的 this和其他語言的 this不同，this的值將取決於它如何被呼叫。 使用 ⇒定義 arrow functions，又稱為「箭號函式」，箭號函式沒有自己 this的值，可以保存外層方法中定義的 this的值。 2. JSX JSX 是 JavaScript 語法的擴充，看起來很像樣板語言，不一樣的是，JSX 裡頭可使用 JavaScript 全部的功能。 const element = &lt;h1&gt;你好，世界！&lt;/h1&gt;; UI、狀態與邏輯 在前端中，狀態邏輯與使用者介面本就是密不可分的，與其將之拆開到各個檔案中存放，不如關注在：以組件方式拆分，其中封裝好 UI 與邏輯，而組間之間彼此獨立，互不相依。 為什麼使用 JSX React 中，沒有要求非得使用 JSX，但它整合 UI 與邏輯，是很好的視覺輔助。 介紹 JSX 中可以使用表達式。 可以放入子節點（Children）。 跟 XML 一樣，如果一個標籤是空白的，你可以用 /&gt;立刻關閉這個標籤。 防止 XSS （跨網站指令碼）注入攻擊： React DOM預設先將所有嵌入在 JSX 中的變數，escape 並轉為字串後，才會 render。 透過 Babel 編譯成物件，呼叫 React.createElement()，以「tagName(String), attributes(Object), content(String)」作為參數，回傳 React Element。 建立 JSX const element = &lt;h1 className='greeting'&gt;Hello, World!&lt;/h1&gt;; Babel 編譯，呼叫 React.createElement(tagName, attrs, content) const element = React.createElement( 'h1', { className: 'greeting' }, 'Hello, World!' ); 回傳 React Element，React 讀這些物件紀錄的描述，來 Render DOM。 // 注意：這是簡化過的結構 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world!', }, }; 在 JSX 類型中使用點記法 方便模組化 import React from 'react'; const MyComponents = { DatePicker: function DatePicker(props) { return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;; }, }; function BlueDatePicker() { return &lt;MyComponents.DatePicker color='blue' /&gt;; } 3. Rendering Element 建立 React 應用程式最小的單位是 element。 React Element 是一個單純的 Object，它不是 DOM Element。 React Element 很容易被建立。 React DOM：負責更新 DOM，以符合 React Element。 Element ≠ Component 更精確的說，Element 是由 Components 組成。 Render Element 到 DOM 內 root DOM node：所有在內的 element 都會透過 React DOM 做管理。一個應用程式通常會有一個 root DOM node，也能根據需求獨立建立多個 root DOM node。 &lt;!-- index.html --&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; const element = &lt;h1&gt;Hello, World&lt;/h1&gt;; ReactDOM.render(element, document.getElementById('root')); 更新被 Render 的 Element React Element 是 immutable 的，類比一下：電影中的一個幀，代表特定時間點的 UI。 在實踐中，大部分 React 應用程式只呼叫 ReactDOM.render() 一次。 React 只更新必要的 Element React DOM 會將「react element 與其 children」與先前狀態做比較，只更新必要的 DOM。 思考 UI 在任何時候應該如何呈現，而不是隨著時間的推移去消除錯誤。 4. Component 與 Props 組件是將 UI 拆分成獨立，可重複使用的程式碼，並專注各別程式碼的思考。 定義：像是 JavaScript 的 function，接收任意參數，又稱為 props，將回傳描述畫面的 React Element。 Function Component 與 Class Component 定義組件最簡單的方式：寫個 function，符合上述組件的定義： function component function Welcome(props) { return &lt;h1&gt;Hello, {[props.name](http://props.name/)}&lt;/h1&gt;; } class component class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } 組件需要在作用域中被使用。自定義組件名稱，首字英文大寫。 import React from 'react'; import CustomButton from './CustomButton'; function WarningButton() { // return React.createElement(CustomButton, {color: 'red'}, null); return &lt;CustomButton color='red' /&gt;; } 不要害怕抽離組件，因為已經會抽離組件，所以筆記中不贅述。 Props 是唯讀的 不管使用 function 或是 class 來宣告組件，絕對不能修改自己的 props，保持單向資料流。 所有的 React component 都必須像 Pure function 一般保護他的 props。 // not a pure function function withdraw(account, amount) { account.total -= amount; } 5. State 和生命週期 State 類似於 prop，但它是私有且由 component 完全控制的。 component 被定義為 class 有一些額外的特性，其中一個就是 Local State。 將 function 轉為 class 寫法 建立一個繼承 React.Component的 class 加入 render()空方法 return JSX render()內的 props要寫成 this.props 每次更新時，render() 都會被呼叫。 可以使用 local state 和生命週期方法這些額外特性。 需要 constructor()，並在裡頭初始化數據，使用 super(props)，之後組件中就能取得 props。 加入生命週期方法到 Class 當 component 被 destroy 時，釋放所佔用的資源是非常重要的。 componentDidMount()：會在 component 被 render 到 DOM 之後才會執行，也就是掛載完成的意思，可以做些 DOM 長完才能做的事。 componentWillUnMount()：會在 component 即將卸載前觸發這個生命週期方法，在這裡可以執行要釋放佔用資源的方法，避免 Memory leak。 正確的使用 State 要注意的三件事 除非在 constructor 內，不可以直接改 State，要使用 setState() 方法： // 錯誤！組件不會重新渲染 this.state.username = 'askiebaby'; // 正確！ this.setState({ username: 'askiebaby' }); State 更新可能是非同步的 React 會批次處理 setState()的呼叫，合併為單一的更新，提高效能，所以不可以依賴 this.props與 this.state來「直接計算」新的 state。 // 錯誤！ this.setState({ counter: this.state.counter + this.props.increment, }); 透過傳入一個 function 可以避免 state 的不準確： // 正確！Arrow func this.setState((state, props) =&gt; ({ counter: this.state.counter + this.props.increment, })); // 正確！Normal func this.setState(function(state, props) =&gt; ( return { counter: this.state.counter + this.props.increment, }); ); Shallow Merge 呼叫 setState() 時，React 會 merge 你提供的 object 到目前的 state。 如果 state 包含數個獨立變數： constructor(props) { super(props); this.state = { posts: [], comments: [] }; } componentDidMount() { // 這樣使用 // 只會覆蓋 comments；而 posts 保持完整，沒被更動 this.setState({ comments }) } 也可獨立的呼叫 setState()： componentDidMount() { fetchPosts().then(response =&gt; { this.setState({ posts: response.posts }); }); fetchComments().then(response =&gt; { this.setState({ comments: response.comments }); }); } 由上而下的「單向資料流」 組件彼此獨立地管理其內部 state，每個組件的 state 只能影響 component tree 以下的組件。 假設，父組件 UserInfo與兩個子組件 Avatar、SocialLink： 子組件 Avatar可以接收從父組件 UserInfo來的 props，但它不知道是誰傳給它的，子組件只負責接收。 &lt;UserInfo&gt; &lt;Avatar fullname={this.state.fullname} /&gt; &lt;SocialLink platform={this.state.platform} /&gt; &lt;/UserInfo&gt; 用以下範例，來理解所有 component 都是獨立的： function App() { return ( &lt;div id='app'&gt; &lt;UserInfo /&gt; &lt;UserInfo /&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 6. 事件處理器 事件處理器之於 React Element 與 DOM Element 十分相似，有兩點語法上差異：事件名稱寫法、事件的值的型別。 React/DOM 的事件處理，自己再加上 Vue 的比較 React Element 事件的值的型別 寫法範例 避免瀏覽器預設行為 DOM Element 小寫 string onclick={createPost} 可以在 DOM 的 onclick 屬性中使用 return false React Element 小駝峰 function onClick=&quot;createPost()&quot; 在 function 中明確呼叫 preventDefault Vue Element 使用 vue 內建事件處理器 function v-on:click=&quot;createPost&quot; 可以在事件處理器加上 .prevent 後綴，或 function 中呼叫 preventDefault 備註： 只要在 root DOM element 被 render 時加上一個 listener，應用程式已不需要在綁定 listener。 把 event handler 當成該 class 的方法（慣例） 因為 class 的方法在預設上是沒有被綁定（bound）的，沒綁定的話 this 的值將會是 undefined。 Normal function constructor 內綁定。否則每次要當成 props 傳下去時都需要 bind this。 class Toggle extends React.Component { constructor(props) { super(props); this.state = { isToggleOn: true }; // 為了讓 `this` 能在 callback 中被使用，這裡的綁定是必要的： this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState((state) =&gt; ({ isToggleOn: !state.isToggleOn, })); } render() { return ( &lt;button onClick={this.handleClick}&gt; {this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt; ); } } ReactDOM.render(&lt;Toggle /&gt;, document.getElementById('root')); Class Fields：在 CRA（Create-React-App）中是預設可行的。 class LoggingButton extends React.Component { // 這個語法確保 `this` 是在 handleClick 中被綁定： // 警告：這是一個還在*測試中*的語法： handleClick = () =&gt; { console.log('this is:', this); }; render() { return &lt;button onClick={this.handleClick}&gt;Click me&lt;/button&gt;; } } callback 中使用 arrow function，缺點：有效能問題，當組件 LoggingButton 每次渲染時都會建立一個不同的 callback，若這 callback 被 props 到下一個組件，會有多餘的 re-render。 class LoggingButton extends React.Component { handleClick() { console.log('this is:', this); } render() { // 這個語法確保 `this` 是在 handleClick 中被綁定： return &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;Click me&lt;/button&gt;; } } 原則上以 1. constructor 內綁定 或 2. class field 語法，避免效能問題。 將參數傳給 Event Handler 在傳額外參數 id 給事件處理器時， e 在 Arrow function與 Function.prototype.bind的寫法比較： &lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt; &lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt; Arrow function： e「需要」被明確指定的傳下去，在上述範例中作為第二個參數。 Function.prototype.bind：e「不需要」明確指定，即可傳下去。 Reference Hello World - React Docs","link":"/react-main-concepts-part-1/"},{"title":"系統設計入門：內容傳遞網路 CDN","text":"本系列文並非自己心得記錄，而是讀 System Design Primer 的筆記，有蠻大部分節錄自該文章以及其補充連結。 CDN 的出現 網站在流量不高時，使用者對伺服器的回應速度較沒有感覺，但流量漸漸增加時，latency 就會拉長，我們通常會採購新的 sever 來負擔網站流量。 NGINX 建立網站之初，客群會比較侷限或小眾，所以流量增加時，採購新的 server 還算堪用，架個由 Igor Sysoev 開發的 Nginx 輕量級網頁伺服器可以在傳輸時用 Gzip 壓縮，降低 Latency。不過如果使用者越來越喜歡我們的服務，當使用者遍佈全球時，我們總不能在世界各地都買些伺服器來回應使用者（當伺服器離使用者越近，獲得 response 速度增加），而且有些瀏覽器不支援 Gzip。 因應全球佈局策略 在各個 Region 放置我們的伺服器顯然無法真正解決 latency 的問題，因為台灣流量進來了，也可能透過美國的伺服器傳送給使用者。而光速是固定的，所以地理的距離確實影響使用者經驗很大。 CDN 的簡述 在多個地點，擁有多個伺服器群，提供相同的內容給使用者。 翻譯蒟蒻：先幫你把快取的靜態內容抓到 CDN 服務的伺服器群，當瀏覽器發出請求時，藉由獨特的運算法找出離使用者最近的伺服器 IP，請瀏覽器向那個 IP 拿取內容遞送給使用者。 CDN 的優點 降低管理成本 不用全世界到處設伺服器 提升使用者經驗 就近取得內容 伺服器因分佈、頻寬帶來的 Latency 加快 TCP 三次交握的時間 可以用壓縮的方式來傳輸內容 因為壓縮，所以流量變小，加快傳輸時間 克服瀏覽器對於 Gzip 壓縮的支援度 目前各瀏覽器與伺服器基本上都支援，傳輸時的資源壓縮，主流使用 gzip 與 br 壓縮。可以打開任一網頁，查看開發者工具的 Network頁籤 &gt; 任一個請求 &gt; Response headers，裡面有個屬性 content-encoding 會紀錄伺服器使用的壓縮工具。 提供高可用性 減少 DDoS 阻斷服務攻擊（用流量塞爆 bandwidth，造成服務直接無法被使用） 不同地點做以相互備援 CDN 的種類 HTTP Push CDN（主動分發） 我們自己將靜態內容上傳的 CDN 伺服器，適合較小流量或是不常更新的內容。 Pull CDN（被動分發） 我們可以設定靜態內容想被 CDN 快取的 TTL 存活時間，當請求進來時，CDN 服務發現距離最近的伺服器中已無「快取有效的內容」時，就會 Pull 最新的檔案內容。 Apple 發表大會時，在 CEO 發表最新產品後，Apple 的網站當下就要馬上能被全世界的果迷查詢到新產品得網頁內容，這樣的同步是怎麼做到的呢？ 最新網頁內容早已準備好！ 在大會現場，CEO 一講完，工程師在台下透過操作 TTL 存活時間，讓網站內容失效，果迷去訪問蘋果網站時，CDN 找不到快取內容，會發動 Pull 去拉最新資料回來給使用者。 Live Streaming 直播串流 VoD Streaming 影片也能 CDN，Youtube 就是利用 CDN 服務讓使用者可以在最近的伺服器取得內容，去重複播放或回放。常見的 OTT 服務包括：Netflix、LineTV、LiTV 等。 之前有機上盒播放侵權的盜版影片的新聞，其犯罪就是利用 VoD Streaming CDN。 CDN 的缺點 缺點不外乎成本稍高，或是使用者分佈在 CDN 沒有服務的國家。我個人覺得最需要考量的因素是，以資安考量，我們是否願意將公司的網站文件控制權交由另一家公司負責？ 如果預算有空間，且服務流量也頗不錯，CDN 就是寶。 Reference Image CDN CDN - Microsoft","link":"/system-design-cdn-content-delivery-network/"},{"title":"系統設計入門：延遲與吞吐量","text":"本系列文並非自己心得記錄，而是讀 System Design Primer 的筆記，有蠻大部分節錄自該文章以及其補充連結。 話說這兩個詞彙（Latency 和 Throughput）常常會被搞混，有時候可以交換使用，不過自己本來不是讀資訊相關背景，加上本身寫前端，看到這兩個字真的是生字，一點實務上的聯想都想不到，如果你也不懂的話，沒關係，下文會寫筆記來解釋…。 定義 Latency 延遲 執行一個操作要花費的「時間長度」。 Throughput 吞吐量 以一個時間區間作為單位，單位時間內可以執行「幾次」操作，或運算的「次數」。 讀的文章提及，系統設計要以： 可接受的延遲數量下的最大化吞吐量為設計目標。 簡單例子 拍謝，有點文鄒鄒看不懂，以簡單例子來舉例： 有個專門製造汽車的工廠，它製造 1 輛汽車所需要的時間是 8 個小時，而它的生產線在 1 天當中可以製造 120 輛汽車。 Latency 延遲：8 小時。 Throughput 吞吐量：1 天 120 輛汽車，或者是 1 個小時 5 輛汽車。 這樣有比較理解了吧！ Latency 指的是單項事件所需花費的「時間、時間、時間」，！ 而 Throughput 則是在一定的時間內能夠完成的「次數、次數、次數」。 系統設計師可以用來根據效能規範建立所需硬體的參數。 How about web Latency in web Latency 是效能的一環，它讓我們得以量化，有所依規的來訂定優化的標準。那以 Web 來說的話，Latency 指的就是使用者自發出請求後，等待伺服器回應並回傳給使用者的總花費時間，也等同代表網站「被訪問的速度」。對於第一個請求，對於前面的 14Kb 位元，延遲時間會比較長，因為它包括 DNS 查詢、 TCP 三次握手和安全 TLS 協定。 在 Chrome 的開發者工具 Network 中，可以將資源按照以下內容排序。 本區段整理自 Aima 這篇文章。 Start Time：請求開始的時間 Response Time：資源開始下載的時間 End Time：請求結束的時間 Total Duration：請求整個完整過程的時間 Latency 請求等待響應的時間 我們這時來看一下，開發者工具 Network 中有什麼常用的功能。 Network on Chrome DevTools 點擊單項請求的內容可以看到 Headers Preview Response Initiator Timing - 連線時間、請求時間、回應時間、檔案下載時間 Cookies - 請求有帶哪些 cookies 關於延遲的 Web 相關技術 圖片的 Lazy Loading 這個部分我有實作過，原理是將圖片的路徑放在 data-set 中，再設定設計好的「載入中 placeholder」，透過 Intersection Observer API 來監聽元素是否進入畫面，當圖片元素進入畫面時，透過 JS 將 src 替換掉。需考量瀏覽器支援度。 延遲載入 3rd party， &lt;script&gt; 的屬性 defer 和 async。 以下兩者載入過程相同：渲染 DOM 與載入 JS 以非同步方式進行。 defer：執行時間要等到 DOM 解析完成後，才會執行。 async：執行時間是在於 JS 本身載入完成後馬上執行，會中斷 HTML 解析。 Preload 和 Prefetch Preload：預先載入，但不執行，只在需要時才執行，以 as 屬性分辨檔案類型。 &lt;link rel=&quot;preload&quot; src=&quot;style.css&quot; as=&quot;style&quot;&gt; Prefetch：告訴瀏覽器未來可能用到這個資源，有空再去載就好。 &lt;link rel=&quot;prefetch&quot; src=&quot;style.css&quot; type=&quot;style&quot;&gt; Webpack Code spliting Lodash Throttle、Debounce 關於 Latency 的介紹，可以看 MDN 介紹。 Resource System Design Primer Understanding Latency versus Throughput Understanding latency - MDN Preload vs Prefetch - Summer","link":"/system-design-primer-latency-vs-throughput/"},{"title":"無障礙網站：HTML 元素與客製化控制組件的語義","text":"TL;DR 本篇文章學習目的： 理解 HTML 之於瀏覽器與的示能性 理解 HTML 元素與客製化控制組件的語義賦予方式之差異 Affordance 示能性 大家知道 affordance 是什麼嗎？講到 affordance ，大多數的慣例都會使用一個茶壺來做舉例！ （圖片出處：unsplash） 我們看到茶壺（目標物），不用怎麼細細思考，就能知道茶壺可以拿起來倒茶（功能性），這就是 affordance 示能性。 使用者看到網頁內容，立即知道該怎麼操作，這不僅是因為我們看得見它，也是 UI/UX 的示能性。瀏覽器或螢幕閱讀器獲取網頁結構，立即知道元素代表的意義，這是 HTML 的示能性。而這篇文章要談的就是 HTML 的之於的示能性！ 讓網站符合 HTML 規範 符合 HTML 規範的網站，本身就具有良好的可訪問性（Accessibility），有助於提升 SEO，也將提升螢幕閱讀器對於網頁元素的理解程度，撰寫這樣的網站是作為工程師的使命，維護每個人公平獲取資訊的權利。 語義 Semantics 瀏覽過程 瀏覽網站的過程，是一個連貫的操作行為，包含上下瀏覽（導覽） ⇒ 查找（操作） ⇒ 確認 ⇒ 獲得資訊。 整個過程中，確保使用者隨時能知曉： Where：「自己身在網站何處？」 What：「目前操作的是什麼功能啊？這是我要的資訊嗎？」 How：「預期操作之後會發生什麼事？」 以下分為「HTML 元素」與「客製化控制項」，來解釋語義。 HTML 元素的語義 HTML 元素本身已經具有其「基礎定義」，但是能否讓瀏覽器、螢幕閱讀器、爬蟲知曉元素的意義，要看這個基礎定義是否能清楚代表其內容，比如說 HTML 5 提供的語義標籤就非常清楚。 比如 &lt;div&gt; 元素的基礎定義代表的是群組，在 VoiceOver 讀出時是「Group」，使用者無法透過「Group」瞭解區塊的內容。可是 &lt;button&gt; 就不同了，當 VoiceOver 讀出時是「Button」，使用者可以預測它的操作行為：這個區塊可以「點擊」，至於點擊會發生什麼事情，就要倚靠 &lt;button&gt; 中提供清晰的指示內容了。 範例一、當螢幕閱讀器使用者遇到 &lt;button&gt; 的日常： Where？ 噢，我現在停在登入表單的送出按鈕上！ What？ 螢幕閱讀器告訴我，「它」是一顆按鈕，所以我可以「點」進去看看。 How？ 按鈕上的「註冊」文字，讓我知道點擊代表的動作，預測按下按鈕可以完成註冊。 範例二、HTML 5 的語義標籤 HTML 5 中，採用了 &lt;figure&gt; 與 &lt;figcaption&gt; 元素來做到更完整的語意標記。 更有效的分離「圖片的說明」與圖說「想要傳達的概念」，讓內容更具結構。 &lt;figure&gt; &lt;img src=&quot;picture.jpg&quot; class=&quot;picture&quot; alt=&quot;這是人在使用手機的圖片&quot; /&gt; &lt;figcaption&gt;手機改變了這世界&lt;/figcaption&gt; &lt;/figure&gt; 補充：HTML 4 的元素列表、HTML 5 標籤在各瀏覽器的支援程度、使用 HTML 5 語義標籤的頁面（你可以使用各種裝置來瀏覽測試看看）。 備註：不要糾結 &lt;section&gt; 與 &lt;article&gt; 是誰包誰，全看結構是否符合其元素的描述。 客製化控制項的語義化 什麼是客製化控制項？ 就是組合多個具有語義、無語義的 HTML 標籤，透過 JavaScript 操控，讓使用者可以操作的組件，比如：照片燈箱 Modal。 我們現在的網站都已經演變成較複雜的應用程式，即使再簡單的網站，都因應手機時代來臨，智慧型裝置的顯示畫面較小，所以縮減某些區塊呈現範圍的需求，比如說，導航列到手機的介面會呈顯成一個「漢堡」的形狀，點擊那顆「漢堡」選單將收合導覽列的內容。 如何讓螢幕閱讀器知道「漢堡選單」的開關？ 這時候 WAI-ARIA 就派上用場了！目前需要使用 aria 屬性來操作 Accessibility Tree（新增、覆蓋、刪除），我們也能夠過開發者工具來檢視 Accessibility Tree。 什麼是 The Accessibility Tree？我只聽過 DOM Tree 上面的影片是關於 The Accessibility Tree 的簡單介紹。 DOM 與 AOM、The Accessibility Tree 之間的關係 （圖片出處：AOM - WICG） The Accessibility Tree： 基於 DOM Tree 創建出的「無障礙樹」，實際上是擷取出螢幕閱讀器需要的資訊（節點），限於螢幕閱讀器如 NVDA、VoiceOver 解析，這些輔助科技將會與 Audio UI、Spoken UI 結合，念出畫面中的資訊給使用者聽。現階段工程師能實踐無障礙的做法。 DOM： JavaScript 可操縱的介面，由瀏覽器 Google Chrome、Firefox、Safari 解析，渲染成 GUI 可視的人機操作介面。 AOM： 目前還在標準草稿的新 API 計畫！全名 Accessibility Object Model，由 Google 的 Alice Boxhall、Dominic Mazzoni，Apple 的 James Craig 及 Mozilla 的 Alexander Surkov 協作開發，創建聲明式的 JavaScript API。將分為四個階段導入。現階段各瀏覽器的實作狀態請查看這份文件。 Apple 也發布官方聲明（2019-05-17），說明在 iOS 與 macOS 中如何開啟實驗性的 AOM。 Reference AOM - WICG @githbub The Accessibility Tree - Google Developers Playing with the Accessibility Object Model (AOM) Meaning without markup: Accessibility Object Model AOM at me bro - &lt;shortdiv /&gt;","link":"/web-accessibility-html-semantic-elements/"},{"title":"客製化你的部落格網址：Hexo blog x GitHub Pages","text":"你有使用 Hexo 架設部落格嗎？可以透過我的經驗分享，一步一步教你如何設定你的個人網址，簡單擁有自己的網路識別唷！ 必要 Prerequisites 先註冊好你的網址，比如說，我的部落格網址是 askie.today。 準備好透過 GitHub Pages 架的 Hexo 部落格與 Repository。 設定步驟 Configuration 設定 DNS 資訊：A Record 與 CNAME 前往你註冊網域的平台，來設定 DNS 的紀錄，我是在 Godaddy 上購買我的網域。 首先設定 CNAME，www 要指向 &lt;your-github-account&gt;.github.io 再來設定 A Record，@任意指向一台 GitHub 的主機 IP，基本上我是設定兩台，DNS Lookup 時會隨機導到其中一台。 185.199.108.153、185.199.109.153、185.199.110.153 、185.199.111.153 備註：一些紀錄是由 Godaddy 自動產生，比如 NS 或 SOA 或 _domainconnect，可以忽略。 Dig 看看 可以在 Terminal 使用 dig 或是 nslookup 語法，來確定我們是否設定正確，DNS 在同步全球的 Record 時需要點時間。 建立 CNAME 檔案 接下來要建立 CNAME 檔案，GitHub 才能識別我們的網站內容要轉導到哪裡。在使用 Hexo 架設的部落格中，我們要將這個 CNAME 檔案建立在 source 資料夾中，之後透過 hexo build 建置靜態網頁時，就能每次都在網站的根目錄下產生這個檔案。 而在 CNAME 檔案中，填上你購買的網域名稱。 比如說，我的內容是： askie.today 更新 GitHub Pages 的設定 前往部落格 Repo 中的 Settings ，在 Custom domain 填上你購買的網域名稱。 接著要設定 HTTPS，不過剛設定完自訂網域名稱後，有可能需要等一下 GitHub。 其實我過 15 分鐘左右的時間，就可以勾選 Enforce HTTPS 來強制啟用 HTTPS，增強安全性。 OK，以上就是單純分享我自訂網域的過程。如果這篇文章有幫助你順利設定你部落格的網域名稱，請大方地在這篇文章留言，讓我知道吧！：） 內容如有錯誤或誤導，再請各位大大指正。","link":"/customize-hexo-blog-url-on-github-pages/"},{"title":"新增 Git GPG Key 增加安全性","text":"GPG Key 可以讓我們的 commit 都確定是我們本人所新增的。我覺得很不錯！！推薦大家使用。 可以照著這篇文章做：參考文章 from Peter。 Preparation 下載並安裝 GPG 的 CLI 工具：Mac OS X 下載處，有兩個檔案，分別是 DMG 和 sigature。 Step 1: 產生 GPG key 檢查版本 gpg --version 透過 gpg 產生 keys ≥ 2.1.17 gpg --full-generate-key &lt; 2.1.17 gpg --default-new-key-algo rsa4096 --gen-key 建議： GitHub 要求 RSA 加密 長度：4096，不建議超過這長度 expiration：絕不 輸入名稱及 Email，比如說公司信箱 設定 GPG 密碼，並確認 Step 2: 確認 顯示新產生的 Key ID，複製起來（ rsa4096 後面那串值） gpg --list-secret-keys --keyid-format LONG Step 3: 擷取 GPG 需要的資料 複製上一步驟取得的 ID，然後執行： gpg --armor --export [ the Key ] gpg --armor --export DEA763A6C33D812A 會顯示： -----BEGIN PGP PUBLIC KEY BLOCK----- XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX -----END PGP PUBLIC KEY BLOCK----- Step 4: 將 GPG Key 加到 GitHub 中 Avatar &gt; Settings &gt; SSH and GPG keys Page 點擊 New GPG Key 複製第三步驟時產生的 GPG Key Step 5: 在 local 端的 config 加上我們的 GPG key ID git config --global user.signingkey [insert id from step 2] Step 6: commit 時預設啟用 GPG git config --global commit.gpgsign true Step 7: Commit 試看看 git commit -S -m &quot;added 2020&quot; 這時會需要輸入 GPG 密碼，就會顯示 verifed。","link":"/git-pgp-keys/"},{"title":"無障礙標章：WCAG 與 NCC 國家通訊傳播委員會的無障礙規範（申請流程與標章使用規定）","text":"十個真實生活中的幫助 Web Accessibility: Essential for some, useful for all. - W3C WAI 一句話道出了重點，無障礙網站之於某些使用者是必需的，卻能使全部的使用者受益。 一個短短七分鐘的影片，也把生活情境融為其中，我們生活中不也是這樣子的嗎？ 無障礙網站的開發流程 （圖片來源：WAI） 當我們能以同理心來開發無障礙的網站後，這邊介紹在開發環節中，扮演重要的角色，彼此之間的關係環環相扣。 若以圖片的替代文字為例： 技術規範：HTML 規範中，定義圖片元素 &lt;img&gt; 的替代文字 alt 屬性。 WAI 指南：WCAG、ATAG、UAAG 定義如何在各種元件中實現可訪問的替代文字。 開發的工程師：提供適當的且貼切的替代文字措辭。 創作工具：用於撰寫含替代文字的 &lt;img&gt; 標籤，如編輯器、用於生成網站的 CMS 內容管理系統。 使用者代理：給替代文字提供了人機介面，如網頁瀏覽器。 檢測工具：用於檢查原始碼是否存在替代文字的工具，如 eslint-plugin-jsx-a11y、axe、koa11y。 輔助科技：將替代文字以各種形式、設備提供給使用者，如螢幕閱讀器。 使用者：透過瀏覽器或是螢幕閱讀器獲取替代文字，取得想瞭解的資訊。 對於開發無障礙網站的角色及流程有所概念之後，來認識幾個必須要知道的詞彙： W3C 全球資訊網協會 W3C 全名為 World Wide Web Consortium，是製定國際 Web 技術標準的組織，現如由 W3C 和 WHATWG 網頁超文字應用技術工作小組共同製定規範（查看 W3C 聲明稿、始末說明）。 一個標準的建立過程： 工作草案 ⇒ 公布審查或修訂的草案 ⇒ 候選推薦標準 ⇒ 提案推薦標準 ⇒ W3C 發布推薦標準（W3C Recommendation）⇒ 後續修訂（列入勘誤表）。 WAI・Web Accessibility Initiative 可訪問性計畫 WAI 是由 Ｗ 3C 推動的網路無障礙計畫組織，制定了 WCAG、ATAG、UAAG 三個不同面向的可訪問指南及多個技術規範（如 WAI-ARIA、音訊、影片、發音、如何評估…等等），讓工程師對無障礙網站實務有個依歸得以遵循。 WCAG：Web 內容無障礙指南 2.1 英文規範、2.1 簡中翻譯．2019 年 3 月 11 日 WCAG 全名為 Web Content Accessibility Guidelines 是 Web 內容無障礙指南， 2018 年 6 月 5 日推出 2.1 版，是以十年前的 2.0 版本內容的擴充，增加認知、學習障礙、視力不佳的輔助技術指南，WCAG 2.1 版本的發布並未棄用或取代 WCAG 2.0，意思是說若符合 2.1 版，也將會符合 2.0 版的內容。目前 W3C 正在如火如荼地開發更高版本的無障礙指南。 ATAG：創作工具無障礙指南 2.0 英文規範、2.0 簡中翻譯・2018 年 6 月 7 日 ATAG 全名為 Authoring Tool Accessibility Guidelines 創作工具無障礙準則，為網頁內容編輯工具提供了指南，促進所有開發者、設計師能更易於創造出無障礙的網站內容。 UAAG：使用者代理無障礙指南 2.0 英文規範 UAAG 全名為 User Agent Accessibility Guidelines 使用者代理無障礙準則，針對 Web 瀏覽器、瀏覽器擴充套件、媒體播放器、閱讀器等，在輔助技術方面製定標準，使未來的瀏覽器更易於使用。 WAI-ARIA 可訪問的網路應用程式 1.1 英文規範 全名為 Accessible Rich Internet Applications Suite，定義如何透過 WAI-ARIA 提供有關該功能的訊息來解決獲取資訊的挑戰，使大眾可以訪問如 Ajax 技術開發的動態內容 Web 應用程式。 可以查看這個網頁「WAI-ARIA 創作實踐 1.1」瞭解實務上該怎麼運用，在後續文章也會多做說明。 國家通訊傳播委員會的無障礙規範 國家通播傳播委員會又稱 NCC， NCC 也是遵從國際的規範來訂定臺灣的無障礙規範，目前是以 2.0 版作為基準。 NCC 網站公告會列出開課訊息。 我們想提高自己網站的可訪問性，要先來了解「三級別、四原則、十二指引」： 三個一致性級別：（查看 WAI 一致性級別的說明） A：最低級別，要符合 A 級需要符合 A 級的成功準則。 AA：要符合 AA 級需要符合 A、AA 級的成功準則。通常符合這個級別的話，已經可以讓大多數的使用者順利瀏覽。 AAA：是最高的級別，要符合 A Ａ A 級需要符合 A、AA、AAA 級的成功準則。 四原則與十二指引：（查看 WAI 快速導覽、2.1 新增的內容） 1. 可感知 Perceivable 訊息和使用者介面組件必須以「可感知」的方式呈現給使用者。 1.1 替代文字：為文字以外的內容提供「相等意義的替代文字」，使其可以轉化為人們需要的其他形式（如字版、點字、語音、符號…等）。 1.2 時間媒體：為所有基於「時間」的媒體（如影片、音訊）提供一個替代的方案。 1.3 適應性：能以不同方式呈現，不喪失資訊或結構的內容。 1.4 可辨識：讓使用者能容易地看見及聽到內容、並區分前景與背景。 2. 可操作 Operable 是否能夠使用鍵盤全程瀏覽網站，使用者遇到錯誤（如表單欄位格式不符），都需要足夠的訊息提示。 2.1 可以鍵盤操作：讓所有的功能都能透過鍵盤使用。 2.2 時間充分： 給使用者足夠時間閱讀並使用內容。 2.3 癲癇： 不以會誘發癲癇的方式設計內容。 2.4 可導覽：提供協助使用者導覽、尋找內容及判斷所在的方法。 3. 可理解 Understandable 讓使用者可以理解每個元素的目的，將所有的文字打得明確、有指示性。 3.1 可讀： 文字訊息需可讀並易理解。 3.2 可預測： 網頁的呈現與操作需可預測。 3.3 輸入協助： 協助使用者避免並更正錯誤。 4. 健壯性 Robust 讓每個人使用不同裝置或設備都能瀏覽網站，並且要能與時俱進。 4.1 相容性：針對目前及未來的使用者代理與輔助科技，最大化其相容性。 補充 WCAG 2.1 相較於 WACG 2.0 更新的內容，我覺得除了可以看 WAI 2.1 新增的內容，這篇文章寫得很仔細，更多的是實務上的應用，以符合規範內容，會比純看規範來得更快速理解。 臺灣的無障礙標章申請流程（查看詳細流程） 各級政府及其附屬機關（構）、學校所建置之網站，應通過第一優先等級（即檢測等級 A）以上之無障礙檢測。106 年度起，各政府機關或學校於網站新設或改版（網址不變）時，應依檢測等級 AA 進行設計。 查看公告 依據身份（公務員或一般民眾）註冊會員並登入。 去這個頁面，依據作業系統下載官方提供的檢測軟體 Freego，目前版本 2.0，依據想通過的等級（A / AA / AAA）全站進行檢測，將報告另存新檔。 填寫承辦人：政府單位網站請勿填寫「承包廠商」作為「承辦人」，一般民眾填寫自己即可。 填寫標章機關代碼：標章的機關名稱請透過「查詢機關代碼」按鈕，查詢並選取機關名稱；無機關代碼者，請選擇「民間團體」。 完整填寫其他必填欄位，並上傳檢測報告，填寫的網址要與報告中相符（如 http、 https ）。 送出，等收信吧，也可以在會員專區查看紀錄！ 若不符合之後的人工檢測，需要自退回修正七個工作天後，才可以再申請。 無障礙標章使用規定（查看詳細說明） 括號 （）為備註內容， 其餘的文字為明確要輸入的內容。 Meta： &lt;meta name=&quot;Accessible_website&quot; content=&quot;本網站通過 A/AA/AAA 檢測等級無障礙網頁檢測&quot; /&gt; 標章格式：圖片樣式建議使用 CSS 設定，下方格式是官方提供，詳見上面說明連結。 &lt;a href=&quot;（收到的標章連結路徑）&quot; title=&quot;無障礙網站&quot;&gt; &lt;img src=&quot;（設定連結至您自行下載的無障礙標章圖檔位置）&quot; alt=&quot;（網站通過檢測的範圍）通過 A/AA/AAA 檢測等級無障礙網頁檢測&quot; border=&quot;0&quot; width=&quot;88&quot; height=&quot;31&quot; /&gt; &lt;/a&gt; 國際相關的政策 因為太多哩，每個關鍵字寫起來都可以自成一篇，既然是這系列文是講述無障礙網站實踐，重點就在於我們理解觀念與規範後的實踐哩！ 這邊幫補些常聽到的關鍵字，想知道的自己搜尋一下啦！ 1. WAI 列出世界因應無障礙網站的政策表格 2. 美國的康復法案 Section 508 3. 英國無障礙網站的指南 PAS 78 4. 聯合國 4.1 [聯合國針對身心障礙的關注與資源](https://www.un.org/development/desa/disabilities/issues.html#accessibility) 4.2 [聯合國針對各類輔助工具的整理](https://www.un.org/disabilities/documents/2019/AssistiveTechnologyDevices2017-Chi.pdf) 5. 國際身心障礙人士公約 CRPD（The UN of Convention on the Rights of Persons with Disabilities） 21 世紀第一個人權公約，影響全球身心障礙者之權利保障。以圖片來簡單看公約內容，第九頁在闡述無障礙。 如果你也關心身心障礙者的權利的話，可以前往衛生福利部身心障礙者權利公約網站！ Reference WAI - W3C Web Accessibility Perspectives - Compilation of 10 Topics/Videos - WAI 無障礙網路空間服務網 - 國家通訊傳播委員會 WCAG 2.1 Guidelines Explained with Examples - The C2 Group @Mediem 認識無障礙網頁設計規範 - 亮怡資訊 無障礙網頁 - Cliff Chao-kuan Lu @SlideShare","link":"/web-accessibility-certificate-tw/"},{"title":"回顧 2021 必須的吧","text":"停更很久，一年又飛走，對 2021 的結論，曾以為是採著偏消極的態度過生活，仔細想似乎是因為太過堅持要把日子積極地過，那就把行程表塞滿，沒有給自己喘息的時間，所以前半年努力衝刺，後半年失去動力而萎糜不振，成長的幅度不如預期。 但我相信應該不至於如此不堪吧？那就一一羅列，實際上 2020 年也嘗試了很多事物，達成某些里程碑，因為每個經驗與經歷是如此重要，那就寫下來，讓我別忘記每個小小而堅定的決定，多麽好玩。明年再調整看看怎樣的步調，可以舒服地、不覺匆忙地繼續向前。 第一次 第一次「志工帶國小營隊」，學著帶遊戲活動、回歸初心地與小孩們相處，嘗試帶給他們資訊素養和難忘的童年回憶。 第一次「浮潛與水肺深潛」，看到大自然的可貴、水有多清澈。 第一次「去綠島」，夜晚躺在沙灘上聽海聲看撒滿硬幣的星空，偶有流星落下。 第一次「在家工作」這麼久的時間，擁有很多必須得誠實面對自己的時間。 第一次「嘗試寬板滑水」，覺得自己很有潛力，很快就能站起來。 第一次「弄線上課程」，從溝通、備課、開講到影片剪輯都碰了一輪。 第一次「上美甲基礎課」，知道為指甲保養的原理和流程。 第一次「玩線上遊戲」，結交了不同類型的朋友，拿到了最強王國。 第一次「爬百岳」，清晨兩三點起床，在合歡北峰頂煮咖啡、吃早餐，穿梭雲海、欣賞日出。 第一次「穿和服」，解解從未出國而今年絕對不適合出國的饞。 第一次「使用沖牙機」，透過牙醫 Youtuber 了解正確的牙齒保健觀念，牙齒美白、刷牙順序、角度等等。 第一次「帶爸媽出去玩」，用單眼紀錄了爸媽難得開心的兩人合照。 挑戰 接案：弄了兩年多的案子終於告一段落，下班之餘少再記掛一件事。（可喜可賀） 志工：參加 Web Accessibility 的讀書會，每週和志同道合的朋友研讀官方文件，希望能同理他人，做出更包容的產品。 興趣：上吉他課，學了幾首歌，擁有了一把 Taylor，交了彈琴的好朋友，也因為這樣而認識現在的 Team Leader。 工作：勇於找尋新的工作機會，Internal Transfer 成功！ 責任：多了一隻賓士貓 Brook。 有趣的嘗試 連續至少 30 天以上核心運動。 嘗試每天正確姿勢打字至少 20 分鐘。 嘗試用電子書取代紙本，讓包包減輕重量。 偶爾早一點起床，早安運動或是瑜伽伸展。 協辦音樂祭的活動，踏入好多年不敢踏入的 Live House（心臟會撕裂）。 幫媽媽辦一個手機門號，教她用 iPhone 打電話和聽音樂；辦爸爸辦了一個門號，滿足他退休後玩 iPad 玩地順暢。 開始使用番茄鐘 Minee 控制工作腦的切換。 下背不適持續，為自己買了 MIT 三節式的升降桌與人體工學椅，除了支持台灣品牌以外，也算是達成工程師的小小成就，終於可以交替站著工作。 因應疫情關係，線上訂閱了大誌半年，希望給人們帶點希望；也捐款給臺灣東部唯一的野生動物醫院，希望給動物帶點希望。 這些挑戰，不是三兩天能做到的事；這些嘗試，也不是非常容易下的決定。很多時候好玩就好。 也許持續不久會選擇放棄，不過每個舉動都能更加認識自己，身體究竟喜歡什麼工作模式？找到自己抒發的管道、放鬆的方式，這樣不是也很好嗎？也許就在每一個機會中，會找到熱情所在。 反正，信念是不變的。 新的一年也不是新的開始，而是每個時刻都值得開始，有幾個精神要延續下去： 醒著就做事，累了就好好休息。 記得以身體的需要為優先，而不是腦袋的想要。 人生有限，我們卻可以創造無限體驗。 希望你/妳有意識地迎向每一天早晨 ☺️","link":"/2021-retrospect/"},{"title":"當趨勢志工社來到花蓮吉安國小 2021","text":"2021 年 1 月 21 日～ 1 月 23 日，當我們這群魔法精靈們來到花蓮縣的吉安國小，和 21 個中高年級的魔法師們，一起進入魔法學校，從頭體驗魔法的冒險故事！ 魔法精靈們 = 志工 第一次參與志工社說明會 加入志工社的決定，那時，是進入趨勢接近一年的時間點。一直都知道公司有非常多元的社團，包含各種運動類型、理財、演講社等等，能文能武，而社團能成熟，全是由許多許多熱心的 Trenders 組織而成，無私付出，在有興趣的領域一同切磋、交流。 那為什麼會選擇趨勢志工社呢？參與了志工社說明會後，才瞭解「施比受更有福」這個信念是不是隨口說說，我們希望可以將資訊教育深植於老師與孩子們心中，尤其偏鄉的孩子在軟體層面比硬體還要更加缺乏。因此，不論自己的能力高低到哪，總有可以付出的地方。 台北 ←→ 花蓮，籌備的那些事兒 在 2021 年 1 月 21 日這天，其實有三隊營隊一同啟程到三間不同地點的偏鄉國小，開啟各自不同的旅程，其中，花蓮吉安國小是為期天數最長的營隊，想當然爾，我們也花費較長的時間準備。所幸營隊擁有經驗值 up 的夥伴們，在全球 COVID-19 疫情依舊嚴峻的時期舉辦活動，要考慮防疫的物資和計畫，大家也客觀地給予真誠建議，整體合作的過程還算舒服。 我們設定的魔法教育 3D 列印 → 自己設計名牌（魔法師執照） Scratch → 自己設計電流急急棒 並從中穿插活動，包含醒腦遊戲、大地遊戲、各類小遊戲，套上小默契口號與故事包裝。 運用小小競賽讓彼此 team work 成真，順便帶著成就感的成品回家。 籌備了什麼？ 場地勘察 動線設計 課程與遊戲內容範圍設定、發想 背景故事包裝 攝影與生活安排 各式試玩、試教會議 教材、道具製作 行前會議、檢討會議 印象深刻的回憶 永遠會記得小孩子最真切的愛現、害羞、聰明、彼此互助。 當孩子完成了某項成就，突然發現其實我們也是在不同時間點的同一條路上繼續完成，可是保有純真很重要。 有位過動的孩子，在營期中願意調整自己、帶著半強迫自己的方式，故意咬著木棍只為不讓自己的行為影響其他同學上課。 營隊夥伴在籌備的過程不輸一般行銷公司辦活動的流程，越趨細緻，經驗也超願意無私分享。 最後，回顧照片：） Happy Ending ☺️ 第一次看 3D 印表機在印刷中 團隊合作的重要性 每個人都認真的設計自己的遊戲創作","link":"/trendmicro-volunteer-club-2021/"},{"title":"幸福捕手筆記：自殺的五大迷思","text":"這篇文章是新北衛什麼的幸福捕手線上課程第 1 彈的筆記。 每次上網查詢關於求助的方式時，基本上會查到許多憂鬱症的量表，第一次看到免費的衛教課程講述得如此詳細，謝謝「諮商心理師許皓宜」解開了一些心裡的結、釐清了迷思、糾正錯誤的觀念，希望能分享給其他正處於迷惑的人們。 近幾年自殺新聞頻傳，而這些自殺的人總是令人意外，平常不覺有異。如果這些人就在我們身邊，或者是自己可能也在自殺的一個想法跟困擾當中，那我們可以怎麼辦？如果你可以理解正確的概念，我們更能在及時的地去幫助這些人。 迷思一：自殺是禁忌話題，最好不要談？ 那麼自殺的五大迷思有什麼呢？第一件事情，很多人會想說自殺是一個「禁忌的話題」，當事人應該不會主動提，所以我們最好也不要跟這個人去談？ 研究顯示，其實超過 60% 的人在要自殺的時候，先前是有做口頭表達的，甚至高達 80% 的人，其實曾經留下過警訊；換句話說，其實如果我們仔細地辨別一些特徵，你會發現你周圍的人可能正處於這個自殺的疑惑當中。 一定**「要」主動關懷他人！** 如果你發現身旁親友好像最近處於低潮，你很擔心他有沒有這樣子的衝動，你當然可以主動地去跟他聊一聊。 生命有其他可能性 為什麼？依照心理學的概念，其實有很多事情在你說完後，能更加地去整理自己的思維，整理完之後，你不見得依然想去做這件事，反而發現生命有很多其他的可能性。 迷思二：自殺的人都有精神問題？ 很多人都覺得想自殺的人一定有精神問題吧？尤其如果看到哪裡有人選擇自殺，大家都會幫他們冠上「他一定有憂鬱症」的這種概念，你覺得這樣的觀念是對的嗎？ 其實，自殺跟精神疾病，它並沒有直接關聯。不過我們可以這樣來形容，自殺的人常常是因為他的外在壓力所帶來的「負荷量」已經超過他這個人本身可以負擔的範圍。自殺這件事情，它是跟壓力相關，而不見得跟精神病那麼相關。 壓力是什麼？ 廣義來說，其實壓力是——所有我們需要花力氣的事情都可以成為壓力。 壓力，它其實可以分成「正壓」還有「負壓」，也就是說，對這個人可以帶來好的影響，也可以帶來不好的影響。 比方說，有些人明天要參加比賽了，同學去幫他加油，這個是不是會造成壓力？ 一定會，可是反而使他的表現更好；同樣的事情，發生在另外一個人的身上，明天要參加比賽，同學去幫他加油，他反而因為壓力太大而失常了，這中間的界線在哪裡呢？ 正壓 vs 負壓 其實有一非常簡單的判斷標準。負壓就是，對這個人而言已經非常困難的事情，你再給他更多的壓力，這個壓力就會造成負壓；而如果對這個人而言是簡單的事情，再給他一點點壓力，這個壓力可能就會變成推動他往前走的因子（正壓）。 非常困難的事情 ⇒ 給予一點壓力 ⇒ 負壓。 簡單的事情 ⇒ 給予一點壓力 ⇒ 正壓。 所以換句話說，如果你是一個媽媽，你已經覺得孩子，他明天的功課已經很難了，他自己已經寫不完，抱著頭在燒了，可是你卻一直問他說，「你到底寫完沒有？寫完沒有？」，那這是正壓還是負壓呢？ 孩子已經覺得困難，而我再給他壓力，這就會造成負壓了。所以，要跟大家釐清一個概念，自殺的行為本身，它跟精神疾病不必然有關聯，而可能跟壓力有關聯。 迷思三：自殺會遺傳？ 答案是「不」。 自殺並不會透過「生理」來遺傳，但是我們會去評估的是，這個人有沒有學習到他家族裡頭使用的這種「處理壓力的方法」，所以如果我周圍有這樣的朋友，我們該關注的是，他有沒有在這種機制以外，學到其他用來解決壓力的方法。 換句話說，這個迷思它是存在的，因為自殺並不會有「生理」的遺傳，但是「學習」上的會有。所以我們要注意的是，假設有位媽媽選擇自殺，那麼孩子他的「心理功能」能不能夠負擔？以及他有沒有去學習到：其實人生不一定是用這種方式來處理，還有其他的可能性。 迷思四：自傷和自殺是一樣的嗎？ 自傷 自傷是什麼？有人會叫做自殘，它就像自傷的一種表現。舉個最簡單的例子，有的時候你會看到，周圍可能有一些朋友或你認識的人，他身上可能穿了很多的環或是耳洞，甚至有些青少年可能有割手的行為。 這些範例，自傷的人在意念上並沒有想要結束自己的生命，他們其實是透過這樣子的方式，讓自己感覺到「痛」的存在，感覺到痛好像就覺得自己「還活著」，所以對自傷的人而言，其實我們要幫助他們找到的是一種「意義感」。 自殺 自殺，它的簡單定義來說，是透過各種間接或是直接的方式，想要結束自己的生命。有的時候一刀下去都是很狠的，如果發現了有自殺意念的人，建議大家要馬上協助轉介。 迷思五：有改善跡象，就表示危機解除？ 有些人會問，有的時候想自殺的人，他們好像很快就會表現出改善的狀況，那麼是不是就代表他們的危機解除了呢？ 自殺是壓力所造成的焦慮 事實上「自殺」其實可以說是一種壓力所造成的焦慮，壓力來源有很多種。也許我現在本來很想死，可是現在這個焦慮，有可能它暫時地就不見了，所以大家要注意的是，它可能明天、後天、或在其他的時間點裡頭，他又出現了自殺的想法。 換句話說，當這個人曾經有過非常強烈的自殺意念，我們要有一陣子的時間地去好好觀察：他是否內心真正的焦慮已經解除？當然，對於一個陪伴者而言是蠻辛苦的，不過很重要的是因為有你的陪伴，會是他每一次亮紅燈的時候，很重要的一個支柱。 結論 正確的觀念 我們在評估上可以分成三個層面來看待。 第一個層面：想法 第一個層面，我們要去看這個人的「自殺想法」有多強烈？假設有朋友的另一半過世，我們聽到朋友這樣說的時候，你的反應會是什麼？ 如果不怕主動跟他談，第一個可以問他說「那你還好嗎？」如果看他非常低落，我就問他說「那你會不會想要傷害自己？」這就是在做「想法」的評估。 第二個層面：計畫 第二個層面，你有沒有類似的「計畫」？當然不可能直接問他說「那你有什麼計畫？」 我們口語上可以問他說「那你想怎麼做呢？」有些人也許會說他的計畫是什麼？比方說，他想到海邊之類的…答案。 第三個層面：行為 然後就可以再問他「那麼你有沒有真的去嘗試這件事情？」 這樣三個步驟，到第三個叫做「行為」的層面。你會發現，原來有這麼多比我們想像還要高的比例的人，他已經不只是一個想法而已，甚至有計畫，而且採取過行動，只是他最後不敢真的跳下去或真的做這件事而已。 而這代表什麼呢？當我們人處於一個覺得生命非常灰暗，非常想死的狀態，其實我們的內在，總有一個「求生意志」要告訴你：也許再停下腳步來，多想一句、轉個身，又看到了新的想法。 如果現在在看的你，自己處於這樣的痛苦當中，或是你發現你旁邊的人，可能有這樣子的困擾，千萬不要再把它當作一個禁忌的話題，好好地去談一談，聽聽自己的心聲，如果發現自己真的需要的時候，就去尋找專業人員，讓我們一起來陪伴別人和陪伴自己度過。","link":"/suicide-explanind-episode-1/"}],"tags":[{"name":"mobile","slug":"mobile","link":"/tags/mobile/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"command line","slug":"command-line","link":"/tags/command-line/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"diff","slug":"diff","link":"/tags/diff/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"callback","slug":"callback","link":"/tags/callback/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"asyncronous","slug":"asyncronous","link":"/tags/asyncronous/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"loop","slug":"loop","link":"/tags/loop/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"ngrok","slug":"ngrok","link":"/tags/ngrok/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"web server","slug":"web-server","link":"/tags/web-server/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"chatbot","slug":"chatbot","link":"/tags/chatbot/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"multipart/formdata","slug":"multipart-formdata","link":"/tags/multipart-formdata/"},{"name":"boundary","slug":"boundary","link":"/tags/boundary/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"react track","slug":"react-track","link":"/tags/react-track/"},{"name":"react入門","slug":"react入門","link":"/tags/react入門/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"css specificity","slug":"css-specificity","link":"/tags/css-specificity/"},{"name":"權重","slug":"權重","link":"/tags/權重/"},{"name":"特定度","slug":"特定度","link":"/tags/特定度/"},{"name":"優先權","slug":"優先權","link":"/tags/優先權/"},{"name":"huli","slug":"huli","link":"/tags/huli/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"git log","slug":"git-log","link":"/tags/git-log/"},{"name":"git commit","slug":"git-commit","link":"/tags/git-commit/"},{"name":"git alias","slug":"git-alias","link":"/tags/git-alias/"},{"name":"deep copy","slug":"deep-copy","link":"/tags/deep-copy/"},{"name":"swallow copy","slug":"swallow-copy","link":"/tags/swallow-copy/"},{"name":"深拷貝","slug":"深拷貝","link":"/tags/深拷貝/"},{"name":"淺拷貝","slug":"淺拷貝","link":"/tags/淺拷貝/"},{"name":"javascript variable","slug":"javascript-variable","link":"/tags/javascript-variable/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"scope","slug":"scope","link":"/tags/scope/"},{"name":"arrow function","slug":"arrow-function","link":"/tags/arrow-function/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"活動","slug":"活動","link":"/tags/活動/"},{"name":"辦活動","slug":"辦活動","link":"/tags/辦活動/"},{"name":"餐點","slug":"餐點","link":"/tags/餐點/"},{"name":"食物中毒","slug":"食物中毒","link":"/tags/食物中毒/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"bundle","slug":"bundle","link":"/tags/bundle/"},{"name":"modules","slug":"modules","link":"/tags/modules/"},{"name":"模組化","slug":"模組化","link":"/tags/模組化/"},{"name":"打包工具","slug":"打包工具","link":"/tags/打包工具/"},{"name":"webpack loader","slug":"webpack-loader","link":"/tags/webpack-loader/"},{"name":"webpack plugin","slug":"webpack-plugin","link":"/tags/webpack-plugin/"},{"name":"webpack css-loader","slug":"webpack-css-loader","link":"/tags/webpack-css-loader/"},{"name":"webpack style-loader","slug":"webpack-style-loader","link":"/tags/webpack-style-loader/"},{"name":"bulma","slug":"bulma","link":"/tags/bulma/"},{"name":"css framework","slug":"css-framework","link":"/tags/css-framework/"},{"name":"rwd","slug":"rwd","link":"/tags/rwd/"},{"name":"css-in-js","slug":"css-in-js","link":"/tags/css-in-js/"},{"name":"css modules","slug":"css-modules","link":"/tags/css-modules/"},{"name":"css scoped","slug":"css-scoped","link":"/tags/css-scoped/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"前端精神時光屋","slug":"前端精神時光屋","link":"/tags/前端精神時光屋/"},{"name":"條件判斷","slug":"條件判斷","link":"/tags/條件判斷/"},{"name":"if else","slug":"if-else","link":"/tags/if-else/"},{"name":"javascript conditions","slug":"javascript-conditions","link":"/tags/javascript-conditions/"},{"name":"js conditions","slug":"js-conditions","link":"/tags/js-conditions/"},{"name":"javascript statement","slug":"javascript-statement","link":"/tags/javascript-statement/"},{"name":"js statement","slug":"js-statement","link":"/tags/js-statement/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"custom user code snippets","slug":"custom-user-code-snippets","link":"/tags/custom-user-code-snippets/"},{"name":"code snippets","slug":"code-snippets","link":"/tags/code-snippets/"},{"name":"user snippets","slug":"user-snippets","link":"/tags/user-snippets/"},{"name":"step by step","slug":"step-by-step","link":"/tags/step-by-step/"},{"name":"snippet generator","slug":"snippet-generator","link":"/tags/snippet-generator/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"},{"name":"google search console","slug":"google-search-console","link":"/tags/google-search-console/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"a11y","slug":"a11y","link":"/tags/a11y/"},{"name":"好想工作室","slug":"好想工作室","link":"/tags/好想工作室/"},{"name":"無障礙網站","slug":"無障礙網站","link":"/tags/無障礙網站/"},{"name":"無障礙","slug":"無障礙","link":"/tags/無障礙/"},{"name":"無障礙規範","slug":"無障礙規範","link":"/tags/無障礙規範/"},{"name":"通用設計","slug":"通用設計","link":"/tags/通用設計/"},{"name":"無障礙設計","slug":"無障礙設計","link":"/tags/無障礙設計/"},{"name":"aria-label","slug":"aria-label","link":"/tags/aria-label/"},{"name":"Accessibility","slug":"Accessibility","link":"/tags/Accessibility/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Accessibile Web","slug":"Accessibile-Web","link":"/tags/Accessibile-Web/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"},{"name":"development","slug":"development","link":"/tags/development/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"開發環境","slug":"開發環境","link":"/tags/開發環境/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"regexp","slug":"regexp","link":"/tags/regexp/"},{"name":"lookbehind assertions","slug":"lookbehind-assertions","link":"/tags/lookbehind-assertions/"},{"name":"正規表達式","slug":"正規表達式","link":"/tags/正規表達式/"},{"name":"ninja","slug":"ninja","link":"/tags/ninja/"},{"name":"javascript ninja 2","slug":"javascript-ninja-2","link":"/tags/javascript-ninja-2/"},{"name":"讀書筆記","slug":"讀書筆記","link":"/tags/讀書筆記/"},{"name":"system design","slug":"system-design","link":"/tags/system-design/"},{"name":"nami","slug":"nami","link":"/tags/nami/"},{"name":"cat","slug":"cat","link":"/tags/cat/"},{"name":"貓咪","slug":"貓咪","link":"/tags/貓咪/"},{"name":"娜美","slug":"娜美","link":"/tags/娜美/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"dockerfile","slug":"dockerfile","link":"/tags/dockerfile/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"the Accessibility Tree","slug":"the-Accessibility-Tree","link":"/tags/the-Accessibility-Tree/"},{"name":"AOM","slug":"AOM","link":"/tags/AOM/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"可及性網站","slug":"可及性網站","link":"/tags/可及性網站/"},{"name":"親和力網站","slug":"親和力網站","link":"/tags/親和力網站/"},{"name":"包容性網站","slug":"包容性網站","link":"/tags/包容性網站/"},{"name":"部落格網址","slug":"部落格網址","link":"/tags/部落格網址/"},{"name":"hexo blog","slug":"hexo-blog","link":"/tags/hexo-blog/"},{"name":"gitHub pages","slug":"gitHub-pages","link":"/tags/gitHub-pages/"},{"name":"gpg key","slug":"gpg-key","link":"/tags/gpg-key/"},{"name":"WCAG","slug":"WCAG","link":"/tags/WCAG/"},{"name":"NCC","slug":"NCC","link":"/tags/NCC/"},{"name":"無障礙標章","slug":"無障礙標章","link":"/tags/無障礙標章/"},{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"Volunteering","slug":"Volunteering","link":"/tags/Volunteering/"},{"name":"趨勢志工社","slug":"趨勢志工社","link":"/tags/趨勢志工社/"},{"name":"吉安國小","slug":"吉安國小","link":"/tags/吉安國小/"},{"name":"偏鄉教育","slug":"偏鄉教育","link":"/tags/偏鄉教育/"},{"name":"壓力","slug":"壓力","link":"/tags/壓力/"},{"name":"自殺","slug":"自殺","link":"/tags/自殺/"},{"name":"自傷","slug":"自傷","link":"/tags/自傷/"},{"name":"新北衛什麼","slug":"新北衛什麼","link":"/tags/新北衛什麼/"},{"name":"幸福捕手","slug":"幸福捕手","link":"/tags/幸福捕手/"}],"categories":[{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"GIT","slug":"GIT","link":"/categories/GIT/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"API","slug":"Server/API","link":"/categories/Server/API/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"活動","slug":"活動","link":"/categories/活動/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"Efficiency","slug":"Efficiency","link":"/categories/Efficiency/"},{"name":"A11Y","slug":"A11Y","link":"/categories/A11Y/"},{"name":"UserExperience","slug":"UserExperience","link":"/categories/UserExperience/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Study Notes","slug":"JavaScript/Study-Notes","link":"/categories/JavaScript/Study-Notes/"},{"name":"System Design","slug":"System-Design","link":"/categories/System-Design/"},{"name":"Nami","slug":"Nami","link":"/categories/Nami/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"diary","slug":"diary","link":"/categories/diary/"},{"name":"Volunteer","slug":"Volunteer","link":"/categories/Volunteer/"},{"name":"心理","slug":"心理","link":"/categories/心理/"}]}